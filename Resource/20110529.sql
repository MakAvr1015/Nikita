/******************************************************************************/
/***          Generated by IBExpert 2011.01.11 29.05.2011 22:01:07          ***/
/******************************************************************************/

/******************************************************************************/
/***      Following SET SQL DIALECT is just for the Database Comparer       ***/
/******************************************************************************/
SET SQL DIALECT 3;



SET TERM ^ ; 


/******************************************************************************/
/*                             prefix 20110529                                */
/******************************************************************************/
create procedure Upd_20110529 as
begin
  if (not exists(select 1 from rdb$relation_fields where rdb$field_name='F_PARTNER_ROZN' )) then
  begin
    execute statement 'ALTER TABLE T_NSI_SKLAD ADD F_PARTNER_ROZN D_INT;';
  end
  if (not exists(select 1 from rdb$relation_constraints where rdb$constraint_name='FK_T_NSI_SKLAD_PARTNER_ROZN' )) then
  begin
    execute statement 'alter table T_NSI_SKLAD add constraint FK_T_NSI_SKLAD_partner_rozn foreign key (F_PARTNER_ROZN) references T_NSI_PARTNER(F_ID);';
  end
end^


execute procedure Upd_20110529;^


drop procedure Upd_20110529;^

/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE OR ALTER PROCEDURE PR_DATE_TO_STR (
    F_DATE DATE)
RETURNS (
    F_VALUE VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE PR_EXPORT_DOC_IN (
    F_ID BIGINT)
RETURNS (
    F_VALUE VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE PR_EXPORT_DOC_MOVE (
    F_ID BIGINT)
RETURNS (
    F_VALUE VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE PR_EXPORT_DOC_OUT (
    F_ID BIGINT)
RETURNS (
    F_VALUE VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE PR_EXPORT_DOCS_BY_PERIOD (
    P_START_DATE DATE,
    P_END_DATE DATE)
RETURNS (
    V_RESULT VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE PR_EXPORT_INVENTORY (
    P_ID BIGINT)
RETURNS (
    R_VALUE VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE PR_EXPORT_PRICE_BY_DOC_OUT (
    F_DOC_OUT BIGINT,
    F_PRICE_ID BIGINT)
RETURNS (
    F_VALUE VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE PR_NSI_SCANCODE_GET (
    SCAN_ID BIGINT,
    F_SCANVALUE VARCHAR(60))
RETURNS (
    F_ID BIGINT,
    F_VALUE VARCHAR(60),
    F_GOOD BIGINT,
    F_COUNT FLOAT,
    F_GOODNAME VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_CALC_INVENTORY (
    F_INVENTORY_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_CALC_PRICE (
    F_PRICE_ID BIGINT,
    F_START_DATE DATE)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_CALC_PRICE_BY_DOC (
    DOC_ID BIGINT,
    START_DATE DATE,
    PRICE_ID BIGINT,
    CHACNGE_PRICE INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_CALC_PRICE_BY_PRICE (
    PARENT_ID BIGINT,
    START_DATE DATE,
    PRICE_ID BIGINT,
    CHACNGE_PRICE INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_COPY_IN2MOVE (
    F_DOC_IN BIGINT)
RETURNS (
    F_MOVE_DOC BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_COPY_IN2PRICE (
    F_DOC_IN BIGINT,
    F_CHANGE_PRICE INTEGER,
    F_PRICE BIGINT)
RETURNS (
    F_DOC_PRICE BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_COPY_PRICE2PRICE (
    P_SOURCE_PRICE BIGINT,
    P_PRICE BIGINT,
    P_CHANGE_PRICE NUMERIC(15,3),
    P_PARTNER_GOOD BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_DOC_OUT_CALC_SKIDKA (
    F_DOC_OUT INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_GET_GOOD_MOOVE (
    F_GOOD BIGINT,
    F_START_DATE DATE,
    F_END_DATE DATE)
RETURNS (
    F_DOC_ID BIGINT,
    F_DOC_DATE DATE,
    F_DOC_NUM VARCHAR(20),
    F_IN_CNT NUMERIC(15,3),
    F_OUT_CNT NUMERIC(15,3),
    F_IN_SUM NUMERIC(15,3),
    F_OUT_SUM NUMERIC(15,3),
    F_PARTNER VARCHAR(60),
    F_PARTNER_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_GET_GOOD_MOOVE_BY_STOCK (
    F_GOOD BIGINT,
    F_START_DATE DATE,
    F_END_DATE DATE,
    F_SKLAD BIGINT)
RETURNS (
    F_DOC_ID BIGINT,
    F_DOC_DATE DATE,
    F_DOC_NUM VARCHAR(20),
    F_IN_CNT NUMERIC(15,3),
    F_OUT_CNT NUMERIC(15,3),
    F_IN_SUM NUMERIC(15,3),
    F_OUT_SUM NUMERIC(15,3),
    F_PARTNER VARCHAR(60),
    F_PARTNER_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_GET_IN_BY_PERIOD (
    F_STR_DATE DATE,
    F_END_DATE DATE)
RETURNS (
    F_GOOD BIGINT,
    F_GOOD_ARTICLE VARCHAR(20),
    F_GOOD_NAME VARCHAR(255),
    F_GOOD_ED_IZM VARCHAR(60),
    F_PARTNER BIGINT,
    F_PARTNER_NAME VARCHAR(255),
    F_NUM_OUT VARCHAR(20),
    F_DATE_OUT DATE,
    F_CNT NUMERIC(15,3),
    F_SUM NUMERIC(15,3),
    F_PRICE NUMERIC(15,3))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_GET_OUT_BY_PERIOD (
    F_STR_DATE DATE,
    F_END_DATE DATE)
RETURNS (
    F_GOOD BIGINT,
    F_GOOD_ARTICLE VARCHAR(20),
    F_GOOD_NAME VARCHAR(255),
    F_GOOD_ED_IZM VARCHAR(60),
    F_PARTNER BIGINT,
    F_PARTNER_NAME VARCHAR(255),
    F_NUM_OUT VARCHAR(20),
    F_DATE_OUT DATE,
    F_CNT NUMERIC(15,3),
    F_SUM NUMERIC(15,3),
    F_PRICE NUMERIC(15,3),
    F_INPUT_PRICE NUMERIC(15,3),
    F_INPUT_SUM NUMERIC(15,3))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_GET_OUT_BY_PERIOD_BY_SKLAD (
    F_STR_DATE DATE,
    F_END_DATE DATE,
    P_SKLAD BIGINT)
RETURNS (
    F_GOOD BIGINT,
    F_GOOD_ARTICLE VARCHAR(20),
    F_GOOD_NAME VARCHAR(255),
    F_GOOD_ED_IZM VARCHAR(60),
    F_CNT NUMERIC(15,3),
    F_SUM NUMERIC(15,3),
    F_PRICE NUMERIC(15,3),
    F_INPUT_PRICE NUMERIC(15,3),
    F_INPUT_SUM NUMERIC(15,3),
    F_SKIDKA_SUM NUMERIC(15,3),
    F_BACK_SUM NUMERIC(15,3),
    F_BACK_CNT NUMERIC(15,3))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_GET_SOURCE_FOR_PRICE
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_GET_SYS_PARAM (
    PARAM_NAME VARCHAR(60))
RETURNS (
    PARAM_VALUE VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_IMPORT_DOC_IN (
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_PARTNER BIGINT,
    F_EXT_BASE VARCHAR(20),
    F_EXT_ID VARCHAR(20),
    F_DOC_TYPE BIGINT)
RETURNS (
    F_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_IMPORT_DOC_IN_STR (
    F_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM VARCHAR(255),
    F_COUNT NUMERIC(15,3),
    F_PRICE NUMERIC(15,3),
    F_EXT_ID VARCHAR(20),
    F_EXT_BASE BIGINT,
    F_DOC_ID BIGINT)
RETURNS (
    F_GOOD_ID BIGINT,
    F_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_IMPORT_DOC_MOVE (
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_SKLAD BIGINT,
    F_EXT_BASE VARCHAR(20),
    F_EXT_ID VARCHAR(20),
    F_DOC_TYPE BIGINT)
RETURNS (
    F_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_IMPORT_DOC_OUT (
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_PARTNER BIGINT,
    F_EXT_BASE VARCHAR(20),
    F_EXT_ID VARCHAR(20),
    F_DOC_TYPE BIGINT,
    F_SKLAD BIGINT)
RETURNS (
    F_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_IMPORT_DOC_OUT_STR (
    F_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM VARCHAR(255),
    F_COUNT NUMERIC(15,3),
    F_PRICE NUMERIC(15,3),
    F_SKIDKA NUMERIC(15,3),
    F_EXT_ID VARCHAR(20),
    F_EXT_BASE BIGINT,
    F_DOC_ID BIGINT)
RETURNS (
    F_GOOD_ID BIGINT,
    F_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_IMPORT_DOC_PRICE (
    F_NUMBER VARCHAR(20),
    F_PRICE BIGINT,
    F_DATE DATE)
RETURNS (
    F_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_IMPORT_DOC_PRICE_STR (
    F_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM VARCHAR(255),
    F_PRICE NUMERIC(15,3),
    F_EXT_ID VARCHAR(20),
    F_EXT_BASE BIGINT,
    F_DOC_ID BIGINT)
RETURNS (
    F_GOOD_ID BIGINT,
    F_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_IMPORT_INVENTORY_DOC_STR (
    F_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM VARCHAR(255),
    F_COUNT NUMERIC(15,3),
    F_EXT_ID VARCHAR(20),
    F_EXT_BASE BIGINT,
    F_DOC_ID BIGINT)
RETURNS (
    F_GOOD_ID BIGINT,
    F_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_IMPORT_NSI_GOOD (
    F_ID BIGINT,
    F_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_PARTNER BIGINT,
    F_EXT_BASE BIGINT)
RETURNS (
    F_GOOD_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_IMPORT_NSI_PARTNER (
    F_NAME VARCHAR(60),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20),
    F_ADDRESS VARCHAR(255),
    F_EXT_BASE VARCHAR(20),
    F_EXT_ID VARCHAR(20))
RETURNS (
    F_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_IMPORT_NSI_PRICE (
    F_PRICE_ID BIGINT,
    F_PRICE_NAME VARCHAR(60))
RETURNS (
    F_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_IMPORT_NSI_SCANCODE (
    F_GOOD BIGINT,
    F_SCANCODE VARCHAR(20))
RETURNS (
    F_RESULT SMALLINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_INVENTORY_MAKE_DOCS_BY_REZ (
    F_INVENTORY_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_MONEY_IN_AUTO (
    F_MONEY BIGINT,
    F_SUM NUMERIC(15,3) = -1)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_ROUND (
    F_VALUE FLOAT,
    F_RND FLOAT)
RETURNS (
    F_RESULT NUMERIC(10,3))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_SET_PRICE_FROM_NSI (
    F_PRICE BIGINT,
    F_DOC BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_SET_SYS_PARAM (
    PARAM_NAME VARCHAR(60),
    PARAM_VALUE VARCHAR(60))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_IN_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_IN_GET (
    DOC_ID BIGINT,
    DOC_TYPE BIGINT = 0)
RETURNS (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(60),
    F_DATE DATE,
    F_STATE BIGINT,
    F_PARTNER_NAME VARCHAR(60),
    F_PARTNER_KPP VARCHAR(20),
    F_PARTNER_INN VARCHAR(20),
    F_STATE_NAME VARCHAR(60),
    F_SKLAD_NAME VARCHAR(60),
    F_SKLAD_INN VARCHAR(20),
    F_SKLAD_F_NAME VARCHAR(100),
    F_SKLAD_KPP VARCHAR(20),
    F_PRICE BIGINT,
    F_PRICE_NAME VARCHAR(60),
    F_DOC_TYPE BIGINT,
    F_DOC_SUM NUMERIC(15,3))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_IN_I (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(60),
    F_DATE DATE,
    F_STATE BIGINT,
    F_PRICE BIGINT,
    F_DOC_TYPE BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_IN_S (
    P_DOC_TYPE BIGINT = -1)
RETURNS (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(60),
    F_DATE DATE,
    F_STATE BIGINT,
    F_DOC_COUNT FLOAT,
    F_DOC_SUM NUMERIC(15,3),
    F_SKLAD_NAME VARCHAR(60),
    F_PARTNER_NAME VARCHAR(60),
    F_STATE_NAME VARCHAR(60),
    F_DOC_TYPE BIGINT,
    F_DOC_TYPE_NAME VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_IN_STR_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_IN_STR_I (
    F_ID BIGINT,
    F_DOC_IN BIGINT,
    F_GOOD BIGINT,
    F_PRICE_VAL FLOAT,
    F_CNT FLOAT,
    F_SUM FLOAT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_IN_STR_S (
    DOC_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC_IN BIGINT,
    F_GOOD BIGINT,
    F_PRICE_VAL FLOAT,
    F_CNT FLOAT,
    F_SUM FLOAT,
    F_GOOD_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_SCANCODE VARCHAR(60),
    F_GOOD_DOP_INFO VARCHAR(255),
    F_GOOD_PARTNER BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_IN_STR_S_BY_CNT (
    DOC_ID BIGINT,
    CNT BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC_IN BIGINT,
    F_GOOD BIGINT,
    F_PRICE_VAL FLOAT,
    F_CNT FLOAT,
    F_SUM FLOAT,
    F_GOOD_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_SCANCODE VARCHAR(60),
    F_GOOD_DOP_INFO VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_IN_STR_U (
    F_ID BIGINT,
    F_DOC_IN BIGINT,
    F_GOOD BIGINT,
    F_PRICE_VAL FLOAT,
    F_CNT FLOAT,
    F_SUM FLOAT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_IN_U (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(60),
    F_DATE DATE,
    F_STATE BIGINT,
    F_PRICE BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_GET (
    DOC_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_SKLAD_FROM BIGINT,
    F_SKLAD_TO BIGINT,
    F_NUMBER VARCHAR(60),
    F_DATE DATE,
    F_STATE BIGINT,
    F_STATE_NAME VARCHAR(60),
    F_SKLAD_FROM_NAME VARCHAR(60),
    F_SKLAD_FROM_INN VARCHAR(20),
    F_SKLAD_FROM_F_NAME VARCHAR(100),
    F_SKLAD_FROM_KPP VARCHAR(20),
    F_SKLAD_TO_NAME VARCHAR(60),
    F_SKLAD_TO_INN VARCHAR(20),
    F_SKLAD_TO_F_NAME VARCHAR(100),
    F_SKLAD_TO_KPP VARCHAR(20),
    F_PRICE BIGINT,
    F_PRICE_NAME VARCHAR(60),
    F_DOC_SUM NUMERIC(15,3),
    F_TYPE BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_I (
    F_ID BIGINT,
    F_DATE DATE,
    F_NUMBER VARCHAR(20),
    F_SKLAD_FROM BIGINT,
    F_SKLAD_TO BIGINT,
    F_STATE BIGINT,
    F_DOC_SUM NUMERIC(15,3),
    F_PRICE BIGINT,
    F_TYPE BIGINT,
    F_DOC_COUNT NUMERIC(15,3))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_S
RETURNS (
    F_ID BIGINT,
    F_DATE DATE,
    F_NUMBER VARCHAR(20),
    F_SKLAD_FROM BIGINT,
    F_SKLAD_TO BIGINT,
    F_STATE BIGINT,
    F_STATE_NAME VARCHAR(100),
    F_DOC_SUM NUMERIC(15,3),
    F_PRICE BIGINT,
    F_TYPE BIGINT,
    F_TYPE_NAME VARCHAR(60),
    F_DOC_COUNT NUMERIC(15,3),
    F_SKLAD_FROM_NAME VARCHAR(60),
    F_SKLAD_TO_NAME VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_STR_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_STR_I (
    F_ID BIGINT,
    F_DOC_MOVE BIGINT,
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_CNT NUMERIC(15,3),
    F_PRICE_VAL NUMERIC(15,3))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_STR_S (
    F_DOC_MOVE_IN BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC_MOVE BIGINT,
    F_GOOD_NAME VARCHAR(255),
    F_GOOD_DOP_INFO VARCHAR(10000),
    F_SCANCODE VARCHAR(20),
    F_ED_IZM_SHORT_NAME VARCHAR(60),
    F_ED_IZM_NAME VARCHAR(60),
    F_ARTICLE VARCHAR(20),
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_CNT NUMERIC(15,3),
    F_PRICE_VAL NUMERIC(15,3),
    F_SUM NUMERIC(18,6),
    F_GOOD_PARTNER BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_STR_S_BY_CNT (
    MOVE_DOC BIGINT,
    CNT BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC_MOVE BIGINT,
    F_GOOD BIGINT,
    F_PRICE_VAL FLOAT,
    F_CNT FLOAT,
    F_SUM FLOAT,
    F_GOOD_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_SCANCODE VARCHAR(60),
    F_GOOD_DOP_INFO VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_STR_U (
    F_ID BIGINT,
    F_DOC_MOVE BIGINT,
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_CNT NUMERIC(15,3),
    F_PRICE_VAL NUMERIC(15,3))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_U (
    F_ID BIGINT,
    F_DATE DATE,
    F_NUMBER VARCHAR(20),
    F_SKLAD_FROM BIGINT,
    F_SKLAD_TO BIGINT,
    F_STATE BIGINT,
    F_DOC_SUM NUMERIC(15,3),
    F_PRICE BIGINT,
    F_TYPE BIGINT,
    F_DOC_COUNT NUMERIC(15,3))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_GET (
    DOC_ID BIGINT,
    DOC_TYPE BIGINT = 1,
    DOC_SKLAD BIGINT = null)
RETURNS (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(60),
    F_DATE DATE,
    F_PAYDATE_PLAN DATE,
    F_DOC_SUM NUMERIC(15,3),
    F_STATE BIGINT,
    F_PRICE BIGINT,
    F_PRICE_NAME VARCHAR(60),
    F_STATE_NAME VARCHAR(60),
    F_PARTNER_NAME VARCHAR(60),
    F_PARTNER_ADRES VARCHAR(255),
    F_PARTNER_INN VARCHAR(20),
    F_PARTNER_KPP VARCHAR(20),
    F_PARTNER_BANK VARCHAR(60),
    F_PARTNER_BANK_ADRES VARCHAR(255),
    F_PARTNER_BANK_RSCH VARCHAR(20),
    F_PARTNER_BANK_KSCH VARCHAR(20),
    F_PARTNER_BANK_BIK VARCHAR(20),
    F_SKLAD_NAME VARCHAR(60),
    F_SKLAD_ADRES VARCHAR(255),
    F_SKLAD_F_NAME VARCHAR(60),
    F_SKLAD_U_ADRES VARCHAR(255),
    F_SKLAD_INN VARCHAR(20),
    F_SKLAD_KPP VARCHAR(20),
    F_SKLAD_BANK VARCHAR(255),
    F_SKLAD_BANK_ADRES VARCHAR(255),
    F_SKLAD_BANK_RSCH VARCHAR(20),
    F_SKLAD_BANK_KSCH VARCHAR(20),
    F_SKLAD_BANK_BIK VARCHAR(20),
    F_SKIDKA INTEGER,
    F_PAY_SUM NUMERIC(15,3),
    F_TYPE BIGINT,
    F_TYPE_NAME VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_I (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_STATE BIGINT,
    F_PRICE BIGINT,
    F_PAYDATE_PLAN DATE,
    F_DOC_TYPE BIGINT = 1)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_MAKE_PAY (
    F_DOC_ID BIGINT,
    F_MONEY_TYPE BIGINT = 1,
    F_SUM INTEGER = -1)
RETURNS (
    F_MONEY_IN_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_S (
    DOC_TYPE INTEGER = -1)
RETURNS (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_PAYDATE_PLAN DATE,
    F_STATE BIGINT,
    F_DOC_COUNT FLOAT,
    F_DOC_SUM NUMERIC(15,3),
    F_STATE_NAME VARCHAR(60),
    F_SKLAD_NAME VARCHAR(60),
    F_PARTNER_NAME VARCHAR(60),
    F_DOC_SKIDKA NUMERIC(15,3),
    F_DOC_SKIDKA_PERCENT NUMERIC(15,3),
    F_PRICE_NAME VARCHAR(60),
    F_PRICE BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_STR_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_STR_I (
    F_ID BIGINT,
    F_DOC_OUT BIGINT,
    F_GOOD BIGINT,
    F_PRICE NUMERIC(15,3),
    F_CNT FLOAT,
    F_SUM FLOAT,
    F_SKD NUMERIC(15,3) = 0)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_STR_S (
    DOC_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC_OUT BIGINT,
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_CNT FLOAT,
    F_SUM FLOAT,
    F_GOOD_NAME VARCHAR(255),
    F_PRICE_VAL FLOAT,
    F_ARTICLE VARCHAR(20),
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_SKLAD_OST FLOAT,
    F_SKIDKA NUMERIC(15,3),
    F_GOOD_PARNER BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_STR_S_BY_CNT (
    DOC_OUT BIGINT,
    CNT BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC_OUT BIGINT,
    F_GOOD BIGINT,
    F_PRICE_VAL FLOAT,
    F_CNT FLOAT,
    F_SUM FLOAT,
    F_GOOD_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_SCANCODE VARCHAR(60),
    F_GOOD_DOP_INFO VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_STR_U (
    F_ID BIGINT,
    F_DOC_OUT BIGINT,
    F_GOOD BIGINT,
    F_PRICE_VAL BIGINT,
    F_CNT FLOAT,
    F_SUM FLOAT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_U (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_PAYDATE_PLAN DATE,
    F_STATE BIGINT,
    F_PRICE INTEGER,
    F_SKIDKA INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_GET (
    F_PRICE_DOC BIGINT,
    F_PARENT_PRICE_DOC BIGINT = null)
RETURNS (
    F_ID BIGINT,
    F_NUM VARCHAR(20),
    F_DATE DATE,
    F_PARENT BIGINT,
    F_STATE BIGINT,
    F_PRICE BIGINT,
    F_PRICE_NAME VARCHAR(60),
    F_STATE_NAME VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_I (
    F_ID BIGINT,
    F_NUM VARCHAR(20),
    F_DATE DATE,
    F_PARENT BIGINT,
    F_SATE BIGINT,
    F_PRICE BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_S
RETURNS (
    F_ID BIGINT,
    F_NUM VARCHAR(20),
    F_DATE DATE,
    F_PARENT BIGINT,
    F_STATE BIGINT,
    F_PRICE BIGINT,
    F_PRICE_NAME VARCHAR(60),
    F_STATE_NAME VARCHAR(60),
    F_NACENKA NUMERIC(15,3))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_STR_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_STR_I (
    F_GOOD BIGINT,
    F_PRICE NUMERIC(15,3),
    F_DOC_PRICE BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_STR_S (
    F_DOC_PRICE_ID INTEGER)
RETURNS (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_PRICE NUMERIC(15,3),
    F_DOC_PRICE BIGINT,
    F_GOOD_NAME VARCHAR(255),
    F_GOOD_ARTICLE VARCHAR(20),
    F_OLD_PRICE NUMERIC(15,3))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_STR_U (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_PRICE NUMERIC(15,3),
    F_DOC_PRICE BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_U (
    F_ID BIGINT,
    F_NUM VARCHAR(20),
    F_DATE DATE,
    F_PARENT BIGINT,
    F_STATE BIGINT,
    F_PRICE BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_GET (
    F_INVENTORY_DOC BIGINT,
    F_INV BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_MANAGER VARCHAR(100),
    F_DOC_COUNT NUMERIC(15,3),
    F_INVENTORY BIGINT,
    F_STATE BIGINT,
    F_STATE_NAME VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_I (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_MANAGER VARCHAR(100),
    F_DOC_COUNT NUMERIC(15,3),
    F_INVENTORY BIGINT,
    F_STATE BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_S (
    F_INV BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_MANAGER VARCHAR(100),
    F_DOC_COUNT NUMERIC(15,3),
    F_INVENTORY BIGINT,
    F_STATE BIGINT,
    F_STATE_NAME VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_STR_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_STR_I (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_COUNT NUMERIC(15,3),
    F_INVENTORY_DOC BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_STR_S (
    F_INV_DOC BIGINT)
RETURNS (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_GOOD_ARTICLE VARCHAR(20),
    F_GOOD_NAME VARCHAR(255),
    F_COUNT NUMERIC(15,3),
    F_INVENTORY_DOC BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_STR_U (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_COUNT NUMERIC(15,3),
    F_INVENTORY_DOC BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_U (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_MANAGER VARCHAR(100),
    F_DOC_COUNT NUMERIC(15,3),
    F_INVENTORY BIGINT,
    F_STATE BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_GET (
    F_INVENTORY BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE_START DATE,
    F_DATE_COMPLETE DATE,
    F_SKLAD_NAME VARCHAR(60),
    F_SKLAD BIGINT,
    F_STATE BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_I (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE_START DATE,
    F_DATE_COMPLETE DATE,
    F_SKLAD BIGINT,
    F_STATE BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_S
RETURNS (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE_START DATE,
    F_DATE_COMPLETE DATE,
    F_SKLAD_NAME VARCHAR(60),
    F_SKLAD BIGINT,
    F_STATE BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_STR_S (
    F_INV BIGINT)
RETURNS (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_GOOD_ARTICLE VARCHAR(20),
    F_GOOD_NAME VARCHAR(255),
    F_COUNT_PLAN NUMERIC(15,3),
    F_COUNT_FACT NUMERIC(15,3),
    F_INVENTORY BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_INVENTORY_U (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE_START DATE,
    F_DATE_COMPLETE DATE,
    F_SKLAD BIGINT,
    F_STATE BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_GET (
    F_MONEY_IN BIGINT,
    F_MONEY_TYPE BIGINT)
RETURNS (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_PARTNER_NAME VARCHAR(100),
    F_BANK BIGINT,
    F_BANK_NAME VARCHAR(100),
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_STATE_NAME VARCHAR(100),
    F_STATE BIGINT,
    F_SUMMA FLOAT,
    F_TYPE_NAME VARCHAR(100),
    F_TYPE BIGINT,
    F_DOC_SUM NUMERIC(15,3))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_I (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_BANK BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_STATE BIGINT,
    F_SUMMA FLOAT,
    F_TYPE BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_S
RETURNS (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_PARTNER_NAME VARCHAR(100),
    F_BANK BIGINT,
    F_BANK_NAME VARCHAR(100),
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_STATE_NAME VARCHAR(100),
    F_STATE BIGINT,
    F_SUMMA FLOAT,
    F_TYPE_NAME VARCHAR(100),
    F_TYPE BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_STR_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_STR_I (
    F_ID BIGINT,
    F_DOC BIGINT,
    F_MONEY BIGINT,
    F_SUMMA FLOAT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_STR_S (
    F_MONEY_IN BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC BIGINT,
    F_MONEY BIGINT,
    F_SUMMA FLOAT,
    F_DOC_INFO VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_STR_S_DOC (
    F_DOC_OUT BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC BIGINT,
    F_MONEY BIGINT,
    F_SUMMA FLOAT,
    F_DOC_INFO VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_STR_U (
    F_ID BIGINT,
    F_DOC BIGINT,
    F_MONEY BIGINT,
    F_SUMMA FLOAT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_U (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_BANK BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_STATE BIGINT,
    F_SUMMA FLOAT,
    F_TYPE BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_BANK_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_BANK_GET (
    F_BANK_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20),
    F_K_SCH VARCHAR(60),
    F_BIK VARCHAR(20),
    F_XML VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_BANK_I (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20),
    F_K_SCH VARCHAR(60),
    F_BIK VARCHAR(20))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_BANK_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20),
    F_K_SCH VARCHAR(60),
    F_BIK VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_BANK_U (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20),
    F_K_SCH VARCHAR(60),
    F_BIK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_DOC_IN_TYPES_GET (
    F_ID BIGINT)
RETURNS (
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_DOC_IN_TYPES_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_DOC_MOVE_TYPES_GET (
    F_TYPE BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_DOC_MOVE_TYPES_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_DOC_OUT_TYPES_GET (
    F_ID BIGINT)
RETURNS (
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_ED_IZM_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_ED_IZM_GET (
    F_ED_IZM BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_SHORT_NAME VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_ED_IZM_I (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_SHORT_NAME VARCHAR(20))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_ED_IZM_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_SHORT_NAME VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_ED_IZM_U (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_SHORT_NAME VARCHAR(20))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOOD_IMPORT_PHOTO (
    F_ARTICLE VARCHAR(60),
    F_MMEDIA BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_GET (
    NSI_ID BIGINT,
    F_GRP BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(255),
    F_GOODS_GRP BIGINT,
    F_GOODS_GRP_NAME VARCHAR(60),
    F_ED_IZM BIGINT,
    F_ARTICLE VARCHAR(20),
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_SCANCODE VARCHAR(60),
    F_DOP_INFO VARCHAR(255),
    F_PARTNER BIGINT,
    F_XML VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_GET_BY_SCANCODE (
    SCAN VARCHAR(20))
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(255),
    F_GOODS_GRP BIGINT,
    F_ED_IZM BIGINT,
    F_ARTICLE VARCHAR(20),
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_SCANCODE VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_GRP_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_GRP_GET (
    F_GRP BIGINT,
    F_PARENT_GRP BIGINT)
RETURNS (
    GRP_ID BIGINT,
    F_PARENT BIGINT,
    F_NAME VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_GRP_I (
    F_ID BIGINT,
    F_PARENT BIGINT,
    F_NAME VARCHAR(60))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_GRP_S
RETURNS (
    GRP_ID BIGINT,
    F_PARENT BIGINT,
    F_NAME VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_GRP_U (
    F_ID BIGINT,
    F_PARENT BIGINT,
    F_NAME VARCHAR(60))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_I (
    F_NAME VARCHAR(255),
    F_GOODS_GRP BIGINT,
    F_ARTICLE VARCHAR(20),
    F_ED_IZM BIGINT)
RETURNS (
    F_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_MMEDIA_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_MMEDIA_I (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_NAME VARCHAR(60),
    F_MEMO BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_MMEDIA_S (
    F_GOOD_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_NAME VARCHAR(60),
    F_MEMO BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_MMEDIA_U (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_NAME VARCHAR(60),
    F_MEMO BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_S (
    GRP_ID INTEGER)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(255),
    F_GOODS_GRP BIGINT,
    F_ARTICLE VARCHAR(20),
    F_ED_IZM BIGINT,
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_DOP_INFO VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_U (
    F_ID BIGINT,
    F_NAME VARCHAR(255),
    F_GOODS_GRP BIGINT,
    F_ARTICLE VARCHAR(20),
    F_ED_IZM BIGINT,
    F_DOP_INFO VARCHAR(255))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_XML (
    F_GOOD BIGINT)
RETURNS (
    F_VALUE VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_MONEY_IN_TYPES_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_MONEY_IN_TYPES_GET (
    F_MONEY_TYPE BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_MONEY_IN_TYPES_I (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_MONEY_IN_TYPES_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_MONEY_IN_TYPES_U (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_GET (
    NSI_ID INTEGER)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20),
    F_BANK VARCHAR(255),
    F_BANK_RSCH VARCHAR(20),
    F_BANK_BIK VARCHAR(20),
    F_BANK_KSCH VARCHAR(20),
    F_BANK_ADRES VARCHAR(255),
    F_XML VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_I (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_INFO_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_INFO_GET (
    F_PARTNER BIGINT,
    F_INFO_NAME BIGINT)
RETURNS (
    F_RESULT VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_INFO_I (
    F_ID BIGINT,
    F_PARTNER BIGINT,
    F_INFO_NAME BIGINT,
    F_VALUE VARCHAR(100))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_INFO_S (
    PARTNER_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_PARTNER BIGINT,
    F_INFO VARCHAR(60),
    F_INFO_NAME BIGINT,
    F_VALUE VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_INFO_U (
    F_ID BIGINT,
    F_PARTNER BIGINT,
    F_INFO_NAME BIGINT,
    F_VALUE VARCHAR(100))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_U (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PRICE_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PRICE_GET (
    PRICE_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_FORMULA VARCHAR(255),
    F_ROUND NUMERIC(15,3),
    F_PARENT_OBJECT BIGINT,
    F_SAVE_RESULT SMALLINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PRICE_I (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_PARENT_OBJECT BIGINT,
    F_FORMULA VARCHAR(255),
    F_ROUND NUMERIC(15,3))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PRICE_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_PARENT_OBJECT BIGINT,
    F_FORMULA VARCHAR(255),
    F_ROUND NUMERIC(15,3),
    F_SAVE_RESULT SMALLINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_PRICE_U (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_PARENT_OBJECT BIGINT,
    F_FORMULA VARCHAR(255),
    F_ROUND NUMERIC(15,3),
    F_SAVE_RESULT SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_SCANCODE_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_SCANCODE_GET (
    F_GOOD_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_VALUE VARCHAR(60),
    F_GOOD BIGINT,
    F_COUNT FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_SCANCODE_I (
    F_ID BIGINT,
    F_VALUE VARCHAR(60),
    F_GOOD BIGINT,
    F_COUNT FLOAT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_SCANCODE_S (
    F_SCANCODE VARCHAR(60))
RETURNS (
    F_ID BIGINT,
    F_VALUE VARCHAR(60),
    F_GOOD BIGINT,
    F_COUNT FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_SCANCODE_S_BY_GOOD (
    F_IN_GOOD VARCHAR(60))
RETURNS (
    F_ID BIGINT,
    F_VALUE VARCHAR(60),
    F_GOOD BIGINT,
    F_COUNT FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_SCANCODE_U (
    F_ID BIGINT,
    F_VALUE VARCHAR(60),
    F_GOOD BIGINT,
    F_COUNT FLOAT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_SKLAD_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_SKLAD_GET (
    SKLAD_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_ADDRES VARCHAR(255),
    F_PARTNER BIGINT,
    F_PARTNER_NAME VARCHAR(60),
    F_PARTNER_INN VARCHAR(20),
    F_PARTNER_KPP VARCHAR(20),
    F_PARTNER_ADRES VARCHAR(255),
    F_PARTNER_BANK VARCHAR(255),
    F_PARTNER_BANK_ADRES VARCHAR(255),
    F_PARTNER_BANK_RSCH VARCHAR(20),
    F_PARTNER_BANK_KSCH VARCHAR(20),
    F_PARTNER_BANK_BIK VARCHAR(20),
    F_XML VARCHAR(10000),
    F_PRICE_IN BIGINT,
    F_PRICE_OUT BIGINT,
    F_PRICE_IN_NAME VARCHAR(60),
    F_PRICE_OUT_NAME VARCHAR(60),
    F_PARTNER_ROZN BIGINT,
    F_PARTNER_ROZN_NAME VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_SKLAD_I (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_ADDRES VARCHAR(255),
    F_PARTNER BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_SKLAD_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_ADDRES VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_SKLAD_U (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_ADDRES VARCHAR(255),
    F_PARTNER BIGINT,
    F_PRICE_IN BIGINT,
    F_PRICE_OUT BIGINT,
    F_PARTNER_ROZN BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_STATE_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_STATE_GET (
    STATE_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_PARENT BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_STATE_I (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_PARENT BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_STATE_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_PARENT BIGINT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_NSI_STATE_U (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_PARENT BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_PARTNER_BANK_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_PARTNER_BANK_I (
    F_ID BIGINT,
    F_PARTNER BIGINT,
    F_BANK BIGINT,
    F_R_SCH VARCHAR(60))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_PARTNER_BANK_S (
    F_PARTNER_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_PARTNER BIGINT,
    F_BANK BIGINT,
    F_BANK_NAME VARCHAR(60),
    F_BANK_KPP VARCHAR(20),
    F_BANK_INN VARCHAR(20),
    F_BANK_ADRES VARCHAR(255),
    F_BANK_K_SCH VARCHAR(60),
    F_R_SCH VARCHAR(60),
    F_BANK_BIK VARCHAR(20),
    F_XML VARCHAR(10000))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_PARTNER_BANK_U (
    F_ID BIGINT,
    F_PARTNER BIGINT,
    F_BANK BIGINT,
    F_R_SCH VARCHAR(60))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_PRICE_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_PRICE_GET (
    F_PRICE_ID BIGINT,
    F_GOOD_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_STR_DATE DATE,
    F_MAKE_DATE TIMESTAMP,
    F_VALUE FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_PRICE_I (
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_STR_DATE DATE,
    F_VALUE FLOAT,
    F_SOURCE BIGINT = NULL,
    F_ACTIVE SMALLINT = 1)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_PRICE_S (
    F_PRICE_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_STR_DATE DATE,
    F_MAKE_DATE TIMESTAMP,
    F_GOOD_NAME VARCHAR(255),
    F_VALUE FLOAT,
    F_DEFAULT_SKLAD_OST NUMERIC(15,3),
    F_ARTICLE VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_PRICE_U (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_VALUE FLOAT,
    F_STR_DATE DATE = 'now')
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_REG_GOOD_D (
    F_ID BIGINT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_REG_GOOD_GET (
    F_GOOD BIGINT,
    F_DATE DATE,
    F_SKLAD BIGINT)
RETURNS (
    F_START_OST FLOAT,
    F_MOVE_IN FLOAT,
    F_MOVE_OUT FLOAT,
    F_END_OST FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_REG_GOOD_I (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_SKLAD BIGINT,
    F_DATE DATE,
    F_STR_OST FLOAT,
    F_MOVE_IN FLOAT,
    F_MOVE_OUT FLOAT)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE SP_T_REG_GOOD_S (
    F_SKLAD_IN BIGINT,
    F_DATE_IN DATE,
    F_PRICE BIGINT)
RETURNS (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_SKLAD BIGINT,
    F_DATE DATE,
    F_STR_OST FLOAT,
    F_MOVE_IN FLOAT,
    F_MOVE_OUT FLOAT,
    F_END_OST FLOAT,
    F_GOOD_NAME VARCHAR(255),
    F_GOOD_ARTICLE VARCHAR(20),
    F_GOOD_GRP_NAME VARCHAR(60),
    F_PRICE_VAL NUMERIC(15,3))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE SP_T_REG_GOOD_U (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_SKLAD BIGINT,
    F_DATE DATE,
    F_STR_OST FLOAT,
    F_MOVE_IN FLOAT,
    F_MOVE_OUT FLOAT)
AS
BEGIN
  EXIT;
END^






SET TERM ; ^



/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: TR_GEN_T_DOC_IN_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_DOC_IN_ID FOR T_DOC_IN
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_doc_in_ID,1);

end
^

/* Trigger: TR_GEN_T_DOC_IN_STR_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_DOC_IN_STR_ID FOR T_DOC_IN_STR
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_doc_in_str_ID,1);

end
^

/* Trigger: TR_GEN_T_DOC_OUT_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_DOC_OUT_ID FOR T_DOC_OUT
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_doc_out_ID,1);

end
^

/* Trigger: TR_GEN_T_DOC_OUT_STR_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_DOC_OUT_STR_ID FOR T_DOC_OUT_STR
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_doc_out_str_ID,1);
--  select f_value from SP_T_PRICE_GET(new.f_price,new.f_good) into new.f_price_val;
end
^

/* Trigger: TR_GEN_T_MONEY_IN_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_MONEY_IN_ID FOR T_MONEY_IN
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_money_in_ID,1);

end
^

/* Trigger: TR_GEN_T_MONEY_IN_STR_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_MONEY_IN_STR_ID FOR T_MONEY_IN_STR
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_money_in_str_ID,1);

end
^

/* Trigger: TR_GEN_T_NSI_BANK_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_NSI_BANK_ID FOR T_NSI_BANK
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_nsi_bank_ID,1);

end
^

/* Trigger: TR_GEN_T_NSI_GOODS_GRP_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_NSI_GOODS_GRP_ID FOR T_NSI_GOODS_GRP
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_nsi_goods_grp_ID,1);

end
^

/* Trigger: TR_GEN_T_NSI_GOODS_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_NSI_GOODS_ID FOR T_NSI_GOODS
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_nsi_goods_ID,1);
  if (coalesce(new.f_article,'')='') then
    new.f_article=new.f_id;
end
^

/* Trigger: TR_GEN_T_NSI_PARTNER_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_NSI_PARTNER_ID FOR T_NSI_PARTNER
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_nsi_partner_ID,1);

end
^

/* Trigger: TR_GEN_T_NSI_PRICE_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_NSI_PRICE_ID FOR T_NSI_PRICE
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_nsi_price_ID,1);

end
^

/* Trigger: TR_GEN_T_NSI_SKLAD_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_NSI_SKLAD_ID FOR T_NSI_SKLAD
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_nsi_sklad_ID,1);

end
^

/* Trigger: TR_GEN_T_NSI_STATE_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_NSI_STATE_ID FOR T_NSI_STATE
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_nsi_state_ID,1);

end
^

/* Trigger: TR_GEN_T_PARTNER_BANK_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_PARTNER_BANK_ID FOR T_PARTNER_BANK
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_partner_bank_ID,1);

end
^

/* Trigger: TR_GEN_T_PRICE_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_PRICE_ID FOR T_PRICE
ACTIVE BEFORE INSERT POSITION 0
AS
  declare variable f_id   bigint;
begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_price_ID,1);
end
^

/* Trigger: TR_GEN_T_REG_GOOD_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_REG_GOOD_ID FOR T_REG_GOOD
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_reg_good_ID,1);
  select g.f_end_ost from t_reg_good g where
    g.f_good=new.f_good
    and g.f_sklad=new.f_sklad
    and g.f_date=(select max(s.f_date) from t_reg_good s where s.f_good=new.f_good
        and s.f_sklad=new.f_sklad and s.f_date<new.f_date)
    into new.f_str_ost;
   new.f_str_ost=coalesce(new.f_str_ost,0);
end
^

/* Trigger: TR_GEN_T_SYS_LINKS_ID */
CREATE OR ALTER TRIGGER TR_GEN_T_SYS_LINKS_ID FOR T_SYS_LINKS
ACTIVE BEFORE INSERT POSITION 0
AS

begin
  IF (NEW.f_id IS NULL) THEN 
    NEW.f_id=GEN_ID(GEN_t_sys_links_ID,1);

end
^

/* Trigger: T_DOC_IN_AU0 */
CREATE OR ALTER TRIGGER T_DOC_IN_AU0 FOR T_DOC_IN
ACTIVE AFTER UPDATE POSITION 0
AS
  declare variable good_id  bigint;
  declare variable cnt      FLOAT;
  declare variable reg_id   bigint;
  declare variable f_sys_st bigint;
  declare variable v_in_type bigint;
begin
  /* Trigger text */
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_st;
  select param_value from sp_get_sys_param('IN_DOC_TYPE') into :v_in_type;
  if (new.f_state=f_sys_st and new.f_state>old.f_state) then
  begin
    if (new.f_type=v_in_type) then
    begin
      execute procedure sp_calc_price_by_doc(new.f_id,new.f_date,new.f_price,0);
    end
--------------------------------Регистр товаров-------------------------------
    for
    select
      s.f_good,
      s.f_cnt
    from
      t_doc_in_str s
    where
      s.f_doc_in=new.f_id
      and s.f_cnt>0
    into
      :good_id,
      :cnt
    do
    begin
      reg_id=-1;
      select f_id from t_reg_good where f_good=:good_id and f_sklad=new.f_sklad and f_date=new.f_date into :reg_id;
      --Обновление справочника товаров----
      if (new.f_type=v_in_type) then
        update t_nsi_goods set f_partner=new.f_partner where f_id=:good_id and (f_partner is null);
      ------------------------------------
      if (coalesce(reg_id,-1)>0) then
      begin
        update
          t_reg_good
        set
          f_move_in=coalesce(f_move_in,0)+:cnt
        where f_id=:reg_id;
        reg_id=null;
      end
      else
      if (exists (select f_id from t_nsi_goods where f_id=:good_id)) then
      begin
        insert into t_reg_good(f_good,f_sklad,f_date,f_move_in)
        values(:good_id,new.f_sklad,new.f_date,:cnt);
      end
    end
--------------------------------------
  end
  if (new.f_state<f_sys_st and old.f_state>=f_sys_st) then
  begin
    for
    select
      s.f_good,
      s.f_cnt
    from
      t_doc_in_str s
    where
      s.f_doc_in=new.f_id
    into
      :good_id,
      :cnt
    do
    begin
      reg_id=-1;
      select f_id from t_reg_good where f_good=:good_id and f_sklad=new.f_sklad and f_date=new.f_date into :reg_id;
      if (coalesce(reg_id,-1)>0) then
      begin
        update
          t_reg_good
        set
          f_move_in=coalesce(f_move_in,0)-:cnt
        where f_id=:reg_id;
      end
    end
  end

end
^

/* Trigger: T_DOC_IN_BU0 */
CREATE OR ALTER TRIGGER T_DOC_IN_BU0 FOR T_DOC_IN
ACTIVE BEFORE UPDATE OR DELETE POSITION 0
AS
declare variable f_sys_st bigint;
declare variable f_check_zapas bigint;
begin
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_st;
  select param_value from sp_get_sys_param('CHECK_ZAPAS') into :f_check_zapas;
  if (old.f_state>=f_sys_st and coalesce(new.f_state,old.f_state)=old.f_state and f_check_zapas=1) then
  begin
    exception ex_error 'Нельзя изменять документ с таким статусом. Сначала измените статус';
  end
end
^

/* Trigger: T_DOC_IN_STR_AIUD10 */
CREATE OR ALTER TRIGGER T_DOC_IN_STR_AIUD10 FOR T_DOC_IN_STR
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 10
AS
begin
     update t_doc_in
        set f_doc_count=coalesce(f_doc_count,0)-coalesce(old.f_cnt,0),
        f_doc_sum=coalesce(f_doc_sum,0)-coalesce(old.f_sum,0)
        where f_id=old.f_doc_in;
     update t_doc_in
        set f_doc_count=coalesce(f_doc_count,0)+coalesce(new.f_cnt,0),
        f_doc_sum=coalesce(f_doc_sum,0)+coalesce(new.f_sum,0)
        where f_id=new.f_doc_in;
end
^

/* Trigger: T_DOC_MOVE_AU0 */
CREATE OR ALTER TRIGGER T_DOC_MOVE_AU0 FOR T_DOC_MOVE
ACTIVE AFTER UPDATE POSITION 0
AS
  declare variable good_id  bigint;
  declare variable cnt      FLOAT;
  declare variable reg_id   bigint;
  declare variable f_sys_st bigint;
begin
  /* Trigger text */
  if ((new.f_price<>old.f_price) and (new.f_price is not null)) then
  begin
--    update t_doc_move_str set f_price=(select f_id from SP_T_PRICE_GET(NEW.F_PRICE,f_good)) where f_doc_move=new.f_id;
    update t_doc_move_str
      set f_price_val=(select f_value from SP_T_PRICE_GET(NEW.F_PRICE,f_good)),
      f_price=NEW.F_PRICE
      where f_doc_move=new.f_id;
  end
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_st;
  if (new.f_state=f_sys_st and new.f_state>old.f_state) then
  begin
    --execute procedure sp_calc_price_by_doc(new.f_id,new.f_date,new.f_price,0);
--------------------------------Регистр товаров-------------------------------
    for
    select
      s.f_good,
      s.f_cnt
    from
      t_doc_move_str s
    where
      s.f_doc_move=new.f_id
      and s.f_cnt>0
    into
      :good_id,
      :cnt
    do
    begin
      reg_id=-1;
      select f_id from t_reg_good where f_good=:good_id and f_sklad=new.f_sklad_to and f_date=new.f_date into :reg_id;
      if (coalesce(reg_id,-1)>0) then
      begin
        update
          t_reg_good
        set
          f_move_in=coalesce(f_move_in,0)+:cnt
        where f_id=:reg_id;
        reg_id=null;
      end
      else
      begin
        if (new.f_sklad_to is not null) then
          insert into t_reg_good(f_good,f_sklad,f_date,f_move_in)
            values(:good_id,new.f_sklad_to,new.f_date,:cnt);
      end

      select f_id from t_reg_good where f_good=:good_id and f_sklad=new.f_sklad_from and f_date=new.f_date into :reg_id;
      if (coalesce(reg_id,-1)>0) then
      begin
        update
          t_reg_good
        set
          f_move_out=coalesce(f_move_out,0)+:cnt
        where f_id=:reg_id;
        reg_id=null;
      end
      else
      begin
        if (new.f_sklad_from is not null) then
          insert into t_reg_good(f_good,f_sklad,f_date,f_move_out)
            values(:good_id,new.f_sklad_from,new.f_date,:cnt);
      end
    end
--------------------------------------
  end
  if (new.f_state<f_sys_st and old.f_state>=f_sys_st) then
  begin
    for
    select
      s.f_good,
      s.f_cnt
    from
      t_doc_move_str s
    where
      s.f_doc_move=new.f_id
    into
      :good_id,
      :cnt
    do
    begin
      reg_id=-1;
      select f_id from t_reg_good where f_good=:good_id and f_sklad=new.f_sklad_from and f_date=new.f_date into :reg_id;
      if (coalesce(reg_id,-1)>0) then
      begin
        update
          t_reg_good
        set
          f_move_out=coalesce(f_move_out,0)-:cnt
        where f_id=:reg_id;
      end
      reg_id=-1;
      select f_id from t_reg_good where f_good=:good_id and f_sklad=new.f_sklad_to and f_date=new.f_date into :reg_id;
      if (coalesce(reg_id,-1)>0) then
      begin
        update
          t_reg_good
        set
          f_move_in=coalesce(f_move_in,0)-:cnt
        where f_id=:reg_id;
      end

    end
  end

end
^

/* Trigger: T_DOC_MOVE_BI */
CREATE OR ALTER TRIGGER T_DOC_MOVE_BI FOR T_DOC_MOVE
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_DOC_MOVE_ID,1);
END
^

/* Trigger: T_DOC_MOVE_BI0 */
CREATE OR ALTER TRIGGER T_DOC_MOVE_BI0 FOR T_DOC_MOVE
ACTIVE BEFORE UPDATE OR DELETE POSITION 0
as
declare variable f_sys_st bigint;
declare variable f_check_zapas bigint;
begin
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_st;
  select param_value from sp_get_sys_param('CHECK_ZAPAS') into :f_check_zapas;
  if (old.f_state>=f_sys_st and coalesce(new.f_state,old.f_state)=old.f_state and f_check_zapas=1) then
  begin
    exception ex_error 'Нельзя изменять документ с таким статусом. Сначала измените статус';
  end
end
^

/* Trigger: T_DOC_MOVE_STR_AIUD10 */
CREATE OR ALTER TRIGGER T_DOC_MOVE_STR_AIUD10 FOR T_DOC_MOVE_STR
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 10
AS
begin
     update t_doc_move
        set f_doc_count=coalesce(f_doc_count,0)-coalesce(old.f_cnt,0),
        f_doc_sum=coalesce(f_doc_sum,0)-coalesce(old.f_sum,0)
        where f_id=old.f_doc_move;
     update t_doc_move
        set f_doc_count=coalesce(f_doc_count,0)+coalesce(new.f_cnt,0),
        f_doc_sum=coalesce(f_doc_sum,0)+coalesce(new.f_sum,0)
        where f_id=new.f_doc_move;
end
^

/* Trigger: T_DOC_MOVE_STR_BI */
CREATE OR ALTER TRIGGER T_DOC_MOVE_STR_BI FOR T_DOC_MOVE_STR
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_DOC_MOVE_STR_ID,1);
END
^

/* Trigger: T_DOC_OUT_AU0 */
CREATE OR ALTER TRIGGER T_DOC_OUT_AU0 FOR T_DOC_OUT
ACTIVE AFTER UPDATE POSITION 0
AS
  declare variable good_id bigint;
  declare variable cnt     FLOAT;
  declare variable reg_id  bigint;
  declare variable f_sys_st bigint;
  declare variable v_round numeric(15,3);
begin
  if ((new.f_price<>old.f_price) or (coalesce(old.f_skidka,0)<>coalesce(new.f_skidka,0)) ) then
  begin
    update t_doc_out_str set f_price_val_nsi=(select f_value from SP_T_PRICE_GET(NEW.F_PRICE,f_good)) where f_doc_out=new.f_id;
    --Расчитываем скидку
    execute procedure SP_DOC_OUT_CALC_SKIDKA(new.f_id);
    /*
    select f_round from sp_t_nsi_price_get(new.f_price) into :v_round;
    update t_doc_out_str
      set f_price_val=(select f_value from SP_T_PRICE_GET(NEW.F_PRICE,f_good))*(100-coalesce(new.f_skidka,0))/100.00,
      f_price_val_nsi=(select f_value from SP_T_PRICE_GET(NEW.F_PRICE,f_good))
      where f_doc_out=new.f_id;
    --Округляем цену с учетом скидки
    update t_doc_out_str
      set f_price_val=(select f_result from sp_round(f_price_val,:v_round))
      where f_doc_out=new.f_id;
      */
  end
  /* Trigger text */
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_st;
----------------------------Регистр Товаров------------------------
  if (new.f_state=f_sys_st and new.f_state<>old.f_state) then
  begin
    for
    select
      s.f_good,
      s.f_cnt
    from
      t_doc_out_str s
    where
      s.f_doc_out=new.f_id
    into
      :good_id,
      :cnt
    do
    begin
      reg_id=-1;
      select f_id from t_reg_good where f_good=:good_id and f_sklad=new.f_sklad and f_date=new.f_date into :reg_id;
      if (coalesce(reg_id,-1)>0) then
      begin
        update
          t_reg_good
        set
          f_move_out=coalesce(f_move_out,0)+:cnt
        where f_id=:reg_id;
      end
      else
      if (exists (select f_id from t_nsi_goods where f_id=:good_id)) then
      begin
        insert into t_reg_good(f_good,f_sklad,f_date,f_move_out)
        values(:good_id,new.f_sklad,new.f_date,:cnt);
      end
    end
  end
  if (old.f_state>=f_sys_st and new.f_state<f_sys_st) then
  begin
    for
    select
      s.f_good,
      s.f_cnt
    from
      t_doc_out_str s
    where
      s.f_doc_out=old.f_id
    into
      :good_id,
      :cnt
    do
    begin
      reg_id=-1;
      select f_id from t_reg_good where f_good=:good_id and f_sklad=old.f_sklad and f_date=old.f_date into :reg_id;
      if (coalesce(reg_id,-1)>0) then
      begin
        update
          t_reg_good
        set
          f_move_out=coalesce(f_move_out,0)-:cnt
        where f_id=:reg_id;
      end
    end
  end
---------------------------------------------------------
end
^

/* Trigger: T_DOC_OUT_BUD0 */
CREATE OR ALTER TRIGGER T_DOC_OUT_BUD0 FOR T_DOC_OUT
ACTIVE BEFORE UPDATE OR DELETE POSITION 0
AS
declare variable f_sys_st bigint;
declare variable f_check_zapas bigint;
begin
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_st;
  select param_value from sp_get_sys_param('CHECK_ZAPAS') into :f_check_zapas;
  if (old.f_state>=f_sys_st and coalesce(new.f_state,old.f_state)=old.f_state and f_check_zapas=1) then
  begin
    exception ex_error 'Нельзя изменять документ с таким статусом. Сначала измените статус';
  end
end
^

/* Trigger: T_DOC_OUT_STR_AIUD10 */
CREATE OR ALTER TRIGGER T_DOC_OUT_STR_AIUD10 FOR T_DOC_OUT_STR
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 10
AS
begin
     update t_doc_out
        set f_doc_count=coalesce(f_doc_count,0)-coalesce(old.f_cnt,0),
        f_doc_sum=coalesce(f_doc_sum,0)-coalesce(old.f_sum,0)
        where f_id=old.f_doc_out;
     update t_doc_out
        set f_doc_count=coalesce(f_doc_count,0)+coalesce(new.f_cnt,0),
        f_doc_sum=coalesce(f_doc_sum,0)+coalesce(new.f_sum,0)
        where f_id=new.f_doc_out;
end
^

/* Trigger: T_DOC_OUT_STR_BU0 */
CREATE OR ALTER TRIGGER T_DOC_OUT_STR_BU0 FOR T_DOC_OUT_STR
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  /* Trigger text */
  if (new.f_price<>old.f_price) then
  begin
    --select f_value from SP_T_PRICE_GET(new.f_price,new.f_good) into new.f_price_val;
    select p.f_value from t_price p where p.f_id=new.f_price into new.f_price_val;
  end
end
^

/* Trigger: T_DOC_PRICE_AI0 */
CREATE OR ALTER TRIGGER T_DOC_PRICE_AI0 FOR T_DOC_PRICE
ACTIVE AFTER INSERT POSITION 0
AS
begin
  if (new.f_parent is not null) then
  begin
    INSERT INTO T_DOC_PRICE_STR (
    F_GOOD,
    F_PRICE,
    F_DOC_PRICE)
    select
      f_good,
      f_price_val,
      new.f_id
    from sp_t_doc_in_str_s(new.f_parent);
  end
end
^

/* Trigger: T_DOC_PRICE_AU10 */
CREATE OR ALTER TRIGGER T_DOC_PRICE_AU10 FOR T_DOC_PRICE
ACTIVE AFTER UPDATE POSITION 10
AS
  declare variable f_sys_st bigint;
  declare variable f_str_id bigint;
  declare variable f_str_good bigint;
  declare variable f_price_val numeric(15,3);
begin
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_st;
  if (new.f_state=f_sys_st and new.f_state<>old.f_state) then
  begin
    for
      select
        f_id,
        f_good,
        f_price
      from
        t_doc_price_str
      where
        f_doc_price=new.f_id
      into
        :f_str_id,
        :f_str_good,
        :f_price_val
    do begin
      execute procedure SP_T_PRICE_I(:f_str_good,new.f_price,new.f_date,:f_price_val,:f_str_id);
    end
  end
end
^

/* Trigger: T_DOC_PRICE_BI */
CREATE OR ALTER TRIGGER T_DOC_PRICE_BI FOR T_DOC_PRICE
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_DOC_price_ID,1);
END
^

/* Trigger: T_DOC_PRICE_BIU0 */
CREATE OR ALTER TRIGGER T_DOC_PRICE_BIU0 FOR T_DOC_PRICE
INACTIVE BEFORE UPDATE OR DELETE POSITION 0
as
declare variable f_sys_st bigint;
declare variable f_check_zapas bigint;
begin
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_st;
  select param_value from sp_get_sys_param('CHECK_ZAPAS') into :f_check_zapas;
  if (old.f_state>=f_sys_st and coalesce(new.f_state,old.f_state)=old.f_state and f_check_zapas=1) then
  begin
    exception ex_error 'Нельзя изменять документ с таким статусом. Сначала измените статус';
  end
end
^

/* Trigger: T_DOC_PRICE_STR_BI */
CREATE OR ALTER TRIGGER T_DOC_PRICE_STR_BI FOR T_DOC_PRICE_STR
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_DOC_PRICE_STR_ID,1);
END
^

/* Trigger: T_DOC_PRICE_STR_BIU1 */
CREATE OR ALTER TRIGGER T_DOC_PRICE_STR_BIU1 FOR T_DOC_PRICE_STR
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
AS
declare variable v_price_id bigint;
begin
  if ((coalesce(old.f_good,0)<>coalesce(new.f_good,0)) and (new.f_good is not null)) then
  begin
    select f_price from t_doc_price where f_id=new.f_doc_price into :v_price_id;
    if (v_price_id is not null) then
      select f_value from SP_T_PRICE_GET(:v_price_id,new.f_good) into new.f_old_price;
  end
end
^

/* Trigger: T_INVENTORY_AU0 */
CREATE OR ALTER TRIGGER T_INVENTORY_AU0 FOR T_INVENTORY
INACTIVE AFTER UPDATE POSITION 0
AS
begin
  if ((old.f_date_start<>new.f_date_start or old.f_date_start is null ) and (new.f_date_start is not null)) then
  begin
    insert into t_inventory_str(f_good,f_inventory,f_count_plan)
    select f_good,new.f_id,f_end_ost from SP_T_REG_GOOD_S(new.f_sklad,new.f_date_start,null);
   end
  if (new.f_date_start is null  and old.f_date_start is not null) then
  begin
    delete from t_inventory_str where f_inventory=new.f_id;
  end
end
^

/* Trigger: T_INVENTORY_BI */
CREATE OR ALTER TRIGGER T_INVENTORY_BI FOR T_INVENTORY
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_INVENTORY_ID,1);
END
^

/* Trigger: T_INVENTORY_BU0 */
CREATE OR ALTER TRIGGER T_INVENTORY_BU0 FOR T_INVENTORY
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (new.f_sklad is null and new.f_date_start is not null) then
    exception ex_error 'Склад инвентаризации не определен';
end
^

/* Trigger: T_INVENTORY_DOC_BI */
CREATE OR ALTER TRIGGER T_INVENTORY_DOC_BI FOR T_INVENTORY_DOC
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_INVENTORY_DOC_ID,1);
END
^

/* Trigger: T_INVENTORY_DOC_BUD0 */
CREATE OR ALTER TRIGGER T_INVENTORY_DOC_BUD0 FOR T_INVENTORY_DOC
ACTIVE BEFORE UPDATE OR DELETE POSITION 0
AS
declare variable f_sys_st bigint;
declare variable f_check_zapas bigint;
begin
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_st;
  select param_value from sp_get_sys_param('CHECK_ZAPAS') into :f_check_zapas;
  if (old.f_state>=f_sys_st and coalesce(new.f_state,old.f_state)=old.f_state and f_check_zapas=1) then
  begin
    exception ex_error 'Нельзя изменять документ с таким статусом. Сначала измените статус';
  end
end
^

/* Trigger: T_INVENTORY_DOC_STR_AIUD0 */
CREATE OR ALTER TRIGGER T_INVENTORY_DOC_STR_AIUD0 FOR T_INVENTORY_DOC_STR
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  if (coalesce(new.f_count,0)<>coalesce(old.f_count,0)) then
  begin
    update t_inventory_doc set f_doc_count=coalesce(f_doc_count,0)-coalesce(old.f_count,0)+coalesce(new.f_count,0) where f_id=new.f_inventory_doc;
  end
end
^

/* Trigger: T_INVENTORY_DOC_STR_BI */
CREATE OR ALTER TRIGGER T_INVENTORY_DOC_STR_BI FOR T_INVENTORY_DOC_STR
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_INVENTORY_DOC_STR_ID,1);
END
^

/* Trigger: T_INVENTORY_STR_BI */
CREATE OR ALTER TRIGGER T_INVENTORY_STR_BI FOR T_INVENTORY_STR
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_INVENTORY_STR_ID,1);
END
^

/* Trigger: T_MONEY_IN_BUD0 */
CREATE OR ALTER TRIGGER T_MONEY_IN_BUD0 FOR T_MONEY_IN
ACTIVE BEFORE UPDATE OR DELETE POSITION 0
as
declare variable f_sys_st bigint;
declare variable f_check_zapas bigint;
begin
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_st;
  select param_value from sp_get_sys_param('CHECK_ZAPAS') into :f_check_zapas;
  if (old.f_state>=f_sys_st and coalesce(new.f_state,old.f_state)=old.f_state and f_check_zapas=1) then
  begin
    exception ex_error 'Нельзя изменять документ с таким статусом. Сначала измените статус';
  end
end
^

/* Trigger: T_MONEY_IN_STR_BIUD0 */
CREATE OR ALTER TRIGGER T_MONEY_IN_STR_BIUD0 FOR T_MONEY_IN_STR
ACTIVE BEFORE INSERT OR UPDATE OR DELETE POSITION 0
AS
declare variable f_sys_st bigint;
declare variable f_check_zapas bigint;
begin
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_st;
  select param_value from sp_get_sys_param('CHECK_ZAPAS') into :f_check_zapas;
  if (exists(select f_id from t_money_in m where m.f_id=new.f_money and m.f_state=:f_sys_st) and f_check_zapas=1) then
  begin
    exception ex_error 'Нельзя изменять документ с таким статусом. Сначала измените статус';
  end

end
^

/* Trigger: T_NSI_DOC_IN_TYPES_BI */
CREATE OR ALTER TRIGGER T_NSI_DOC_IN_TYPES_BI FOR T_NSI_DOC_IN_TYPES
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_NSI_DOC_IN_TYPES_ID,1);
END
^

/* Trigger: T_NSI_DOC_MOVE_TYPES_BI */
CREATE OR ALTER TRIGGER T_NSI_DOC_MOVE_TYPES_BI FOR T_NSI_DOC_MOVE_TYPES
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_NSI_DOC_MOVE_TYPES_ID,1);
END
^

/* Trigger: T_NSI_DOC_OUT_TYPES_BI */
CREATE OR ALTER TRIGGER T_NSI_DOC_OUT_TYPES_BI FOR T_NSI_DOC_OUT_TYPES
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_NSI_DOC_OUT_TYPES_ID,1);
END
^

/* Trigger: T_NSI_ED_IZM_BI */
CREATE OR ALTER TRIGGER T_NSI_ED_IZM_BI FOR T_NSI_ED_IZM
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_NSI_ED_IZM_ID,1);
END
^

/* Trigger: T_NSI_GOODS_AI0 */
CREATE OR ALTER TRIGGER T_NSI_GOODS_AI0 FOR T_NSI_GOODS
ACTIVE AFTER INSERT POSITION 0
AS
begin
  /* Trigger text */
  execute procedure sp_t_nsi_scancode_i(null, null,new.f_id,1);
end
^

/* Trigger: T_NSI_GOODS_MMEDIA_BI */
CREATE OR ALTER TRIGGER T_NSI_GOODS_MMEDIA_BI FOR T_NSI_GOODS_MMEDIA
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.f_id is null) then
    new.f_id = gen_id(gen_t_nsi_goods_mmedia_id,1);
end
^

/* Trigger: T_NSI_INFO_NAME_BI */
CREATE OR ALTER TRIGGER T_NSI_INFO_NAME_BI FOR T_NSI_INFO_NAME
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_NSI_INFO_NAME_ID,1);
END
^

/* Trigger: T_NSI_MONEY_IN_TYPES_BI */
CREATE OR ALTER TRIGGER T_NSI_MONEY_IN_TYPES_BI FOR T_NSI_MONEY_IN_TYPES
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_NSI_MONEY_IN_TYPES_ID,1);
END
^

/* Trigger: T_NSI_OBJECTS_BI */
CREATE OR ALTER TRIGGER T_NSI_OBJECTS_BI FOR T_NSI_OBJECTS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_NSI_OBJECTS_ID,1);
END
^

/* Trigger: T_NSI_PARTNER_INFO_BI */
CREATE OR ALTER TRIGGER T_NSI_PARTNER_INFO_BI FOR T_NSI_PARTNER_INFO
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_NSI_PARTNER_INFO_ID,1);
END
^

/* Trigger: T_NSI_SCANCODE_BI */
CREATE OR ALTER TRIGGER T_NSI_SCANCODE_BI FOR T_NSI_SCANCODE
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable v_scnancode varchar(9);
declare variable v_genval    bigint;
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_NSI_SCANCODE_ID,1);
  v_genval=new.f_id;
  if (new.f_value is null) then
  begin
    while (NEW.F_VALUE is null) do
    begin
      v_scnancode=substring(cast(100000000+v_genval as varchar(9)) from 2);
      if (not exists(select f_id from t_nsi_scancode where f_value=:v_scnancode)) then
        new.f_value=v_scnancode;
      else
        v_genval=GEN_ID(GEN_T_NSI_SCANCODE_ID,1);
    end
  end
END
^

/* Trigger: T_NSI_SKIDKA_BI */
CREATE OR ALTER TRIGGER T_NSI_SKIDKA_BI FOR T_NSI_SKIDKA
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.F_ID IS NULL) THEN
    NEW.F_ID = GEN_ID(GEN_T_NSI_SKIDKA_ID,1);
END
^

/* Trigger: T_PRICE_AI0 */
CREATE OR ALTER TRIGGER T_PRICE_AI0 FOR T_PRICE
ACTIVE AFTER INSERT POSITION 0
AS
  declare variable f__id   bigint;
begin
  for
    select f_id
    from
      t_price
    where
      f_good=new.f_good and f_price=new.f_price
      and f_id<>new.f_id
    into
      :f__id do
  begin
    if ((exists(select 1 from t_doc_in_str d where d.f_price=:f__id)) or (exists(select 1 from t_doc_out_str d where d.f_price=:f__id))) then
      update t_price set f_active=0 where f_id=:f__id and f_active=1;
    else
      delete from t_price where f_id=:f__id;
  end
end
^

/* Trigger: T_REG_GOOD_AIUD0 */
CREATE OR ALTER TRIGGER T_REG_GOOD_AIUD0 FOR T_REG_GOOD
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  if (coalesce(new.f_move_in,0)<>coalesce(old.f_move_in,0)) then
  begin
    update t_reg_good set f_str_ost=coalesce(f_str_ost,0)-coalesce(old.f_move_in,0)
    where
        f_good=old.f_good
        and f_sklad=old.f_sklad
        and f_date>old.f_date;
    update t_reg_good set f_str_ost=coalesce(f_str_ost,0)+coalesce(new.f_move_in,0)
    where
        f_good=new.f_good
        and f_sklad=new.f_sklad
        and f_date>new.f_date;
  end
  if (coalesce(new.f_move_out,0)<>coalesce(old.f_move_out,0)) then
  begin
    update t_reg_good set f_str_ost=coalesce(f_str_ost,0)+coalesce(old.f_move_out,0)
    where
        f_good=old.f_good
        and f_sklad=old.f_sklad
        and f_date>old.f_date;
    update t_reg_good set f_str_ost=coalesce(f_str_ost,0)-coalesce(new.f_move_out,0)
    where
        f_good=new.f_good
        and f_sklad=new.f_sklad
        and f_date>new.f_date;
  end

end
^

SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

CREATE OR ALTER PROCEDURE PR_DATE_TO_STR (
    F_DATE DATE)
RETURNS (
    F_VALUE VARCHAR(20))
AS
DECLARE VARIABLE V_DAY VARCHAR(2);
DECLARE VARIABLE V_MONTH VARCHAR(2);
DECLARE VARIABLE V_YEAR VARCHAR(4);
begin
  v_day=cast(extract(day from f_date) as varchar(2));
  if (v_day<10) then
    v_day='0'||v_day;
  v_month=cast(extract(month from f_date) as varchar(2));
  if (v_month<10) then
    v_month='0'||v_month;
  v_year=cast(extract(year from f_date) as varchar(4));
  f_value=v_day||'.'||v_month||'.'||v_year;
  suspend;
end^


CREATE OR ALTER PROCEDURE PR_EXPORT_DOC_IN (
    F_ID BIGINT)
RETURNS (
    F_VALUE VARCHAR(10000))
AS
declare variable F_GOOD_ID bigint;
begin
  select
    '<Document MoveType="DOC_IN" Id="'||f_id||'" DocType="'||f_doc_type||'">'||
    '<wbNumber>'||coalesce(f_number,f_id)||'</wbNumber>'||
    '<wbDate>'||(select f_value from pr_date_to_str(f_date))||'</wbDate>'||
    '<wbSum>'||coalesce(f_doc_sum,coalesce((select sum(s.f_sum) from t_doc_in_str s where s.f_id=g.f_id),0))||'</wbSum>'||
--    '<Recipient>'||
    (select f_xml from sp_t_nsi_sklad_get(f_sklad))||
--    '</Recipient>'||
--    '<Sender>'||
    (select f_xml from sp_t_nsi_partner_get(f_partner))||
--    '</Sender>'||
    '<DocBody>'
  from sp_t_doc_in_get(:f_id) g
  into :f_value;
  suspend;
  for select
    f_good,
    '<Pos>'||
    '<Price>'||(select f_result from sp_round(f_price_val,0.01))||'</Price>'||
    '<Kol>'||(select f_result from sp_round(f_cnt,0.01))||'</Kol>'||
    '<Summ>'||(select f_result from sp_round(f_sum,0.01))||'</Summ>'
  from sp_t_doc_in_str_s(:f_id)
  into
    :f_good_id,:f_value do
  begin
    suspend;
    for select f_value from SP_T_NSI_GOODS_XML(:f_good_id) into :f_value do
    begin
      suspend;
    end
    f_value='</Pos>';
    suspend;
  end
  f_value='</DocBody></Document>';
  suspend;
end^


CREATE OR ALTER PROCEDURE PR_EXPORT_DOC_MOVE (
    F_ID BIGINT)
RETURNS (
    F_VALUE VARCHAR(10000))
AS
declare variable F_GOOD_ID bigint;
begin
  select
    '<Document MoveType="DOC_MOVE" Id="'||f_id||'" DocType="1">'||
    '<wbNumber>'||coalesce(f_number,f_id)||'</wbNumber>'||
    '<wbDate>'||(select f_value from pr_date_to_str(f_date))||'</wbDate>'||
    '<wbSum>'||coalesce(f_doc_sum,coalesce((select sum(s.f_sum) from t_doc_move_str s where s.f_doc_move=g.f_id),0))||'</wbSum>'||
    '<Recipient>'||
    (select f_xml from sp_t_nsi_sklad_get(f_sklad_to))||
    '</Recipient>'||
    '<Sender>'||
    (select f_xml from sp_t_nsi_sklad_get(f_sklad_from))||
    '</Sender>'||
    (
    select
      case
        when coalesce(f_partner,0)>0 then
          (select f_xml from sp_t_nsi_partner_get(f_partner))
        else ''
      end
    from
     sp_t_nsi_sklad_get(f_sklad_from)
     )||
    '<DocBody>'
  from sp_t_doc_move_get(:f_id) g
  into :f_value;
  suspend;
  for select
    f_good,
    '<Pos>'||
    '<Price>'||(select f_result from sp_round(f_price_val,0.01))||'</Price>'||
    '<Kol>'||(select f_result from sp_round(f_cnt,0.01))||'</Kol>'||
    '<Summ>'||(select f_result from sp_round(f_sum,0.01))||'</Summ>'
  from sp_t_doc_move_str_s(:f_id)
  into
    :f_good_id,:f_value do
  begin
    suspend;
    for select f_value from SP_T_NSI_GOODS_XML(:f_good_id) into :f_value do
    begin
      suspend;
    end
    f_value='</Pos>';
    suspend;
  end
  f_value='</DocBody></Document>';
  suspend;
end^


CREATE OR ALTER PROCEDURE PR_EXPORT_DOC_OUT (
    F_ID BIGINT)
RETURNS (
    F_VALUE VARCHAR(10000))
AS
declare variable F_GOOD_ID bigint;
begin
  select
    '<Document MoveType="DOC_OUT" Id="'||f_id||'" DocType="'||coalesce(f_type,1)||'">'||
    '<wbNumber>'||coalesce(f_number,f_id)||'</wbNumber>'||
    '<wbDate>'||(select f_value from pr_date_to_str(f_date))||'</wbDate>'||
    '<wbSum>'||coalesce(f_doc_sum,coalesce((select sum(s.f_sum) from t_doc_out_str s where s.f_doc_out=g.f_id),0))||'</wbSum>'||
--    '<Recipient>'||
    (select f_xml from sp_t_nsi_sklad_get(f_sklad))||
--    '</Recipient>'||
--    '<Sender>'||
    (select f_xml from sp_t_nsi_partner_get(f_partner))||
--    '</Sender>'||
    '<DocBody>'
  from sp_t_doc_out_get(:f_id) g
  into :f_value;
  suspend;
  for select
    f_good,
    '<Pos>'||
    '<Price>'||(select f_result from sp_round(f_price_val,0.01))||'</Price>'||
    '<Skidka>'||(select f_result from sp_round(f_skidka,0.01))||'</Skidka>'||
    '<Kol>'||(select f_result from sp_round(f_cnt,0.01))||'</Kol>'||
    '<Summ>'||(select f_result from sp_round(f_sum,0.01))||'</Summ>'
  from sp_t_doc_out_str_s(:f_id)
  into
    :f_good_id,:f_value do
  begin
    suspend;
    for select f_value from SP_T_NSI_GOODS_XML(:f_good_id) into :f_value do
    begin
      suspend;
    end
    f_value='</Pos>';
    suspend;
  end
  f_value='</DocBody></Document>';
  suspend;
end^


CREATE OR ALTER PROCEDURE PR_EXPORT_DOCS_BY_PERIOD (
    P_START_DATE DATE,
    P_END_DATE DATE)
RETURNS (
    V_RESULT VARCHAR(10000))
AS
declare variable VAR_ID bigint;
declare variable F_SYS_ST bigint;
begin
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_st;
  for select f_id from t_doc_in where f_date between :p_start_date and :p_end_date and f_state>=:f_sys_st into :var_id do
  begin
    for select f_value from pr_export_doc_in(:var_id) into :v_result do
      suspend;
  end
  for select f_id from t_doc_out where f_date between :p_start_date and :p_end_date and f_state>=:f_sys_st into :var_id do
  begin
    for select f_value from pr_export_doc_out(:var_id) into :v_result do
      suspend;
  end
  for select f_id from t_doc_move where f_date between :p_start_date and :p_end_date and f_state>=:f_sys_st into :var_id do
  begin
    for select f_value from pr_export_doc_move(:var_id) into :v_result do
      suspend;
  end

end^


CREATE OR ALTER PROCEDURE PR_EXPORT_INVENTORY (
    P_ID BIGINT)
RETURNS (
    R_VALUE VARCHAR(10000))
AS
DECLARE VARIABLE V_ID BIGINT;
DECLARE VARIABLE V_GOOD BIGINT;
begin
  select
   '<Inventory Id="'||f_id||'">'||
   '<wbNumber>'||coalesce(f_number,f_id)||'</wbNumber>'||
   '<wbDate>'||(select f_value from pr_date_to_str(f_date_start))||'</wbDate>'||
   '<Sklad id="'||f_sklad||'" name="'||f_sklad_name||'"/>'
  from
   sp_t_inventory_get(:p_id)
  into :r_value;
  suspend;
  for
    select
      f_id,
      '<InventoryDoc Id="'||f_id||'">'||
      '<wbNumber>'||coalesce(f_number,f_id)||'</wbNumber>'||
      '<Manager>'||coalesce(f_manager,'')||'</Manager>'
    from
      sp_t_inventory_doc_s(:p_id)
    into :v_id, :r_value do
  begin
    suspend;
    for
      select
        f_good,
        '<Pos>'||
        '<Kol>'||(select f_result from sp_round(f_count,0.01))||'</Kol>'||
        '<Good id="'||f_good||'"> '||
        '<name> <![CDATA['||f_good_name||']]></name>'||
        '<article> <![CDATA['||f_good_article||']]></article>'
      from
        sp_t_inventory_doc_str_s(:v_id)
      into :v_good,:r_value do
    begin
      suspend;
      for
        select '<ScanCode>'||f_value||'</ScanCode>'
        from SP_T_NSI_SCANCODE_S_BY_GOOD(:v_good)
        into :r_value do
      begin
        suspend;
      end
      r_value='</Good></Pos>';
      suspend;
    end
    r_value='</InventoryDoc>';
    suspend;
  end
  r_value='</Inventory>';
  suspend;
end^


CREATE OR ALTER PROCEDURE PR_EXPORT_PRICE_BY_DOC_OUT (
    F_DOC_OUT BIGINT,
    F_PRICE_ID BIGINT)
RETURNS (
    F_VALUE VARCHAR(10000))
AS
begin
  select '<Doc_price f_number="'||f_number||'" price_id="'||:f_price_id||'"' from t_doc_out where f_id=:f_doc_out into :f_value;
  suspend;
  select ' price_name="'||f_name||'">' from t_nsi_price where f_id=:f_price_id into :f_value;
  suspend;
  for
    select
        '<Good id="'||f_good||'"> '||
        '<article> <![CDATA['||f_article||']]></article>'||
        '<name> <![CDATA['||f_good_name||']]></name>'||
/*        '<article>' ||f_article||'</article>'||
        '<name>' ||f_good_name||'</name>'||*/

        '<f_value>'||(select f_value from sp_t_price_get(:f_price_id,f_good))||'</f_value></Good>'
    from sp_t_doc_out_str_s(:f_doc_out) into :f_value do
    begin
      suspend;
    end
  f_value='</Doc_price>';
  suspend;
end^


CREATE OR ALTER PROCEDURE PR_NSI_SCANCODE_GET (
    SCAN_ID BIGINT,
    F_SCANVALUE VARCHAR(60))
RETURNS (
    F_ID BIGINT,
    F_VALUE VARCHAR(60),
    F_GOOD BIGINT,
    F_COUNT FLOAT,
    F_GOODNAME VARCHAR(255))
AS
DECLARE VARIABLE CNT INTEGER;
begin /*$$IBE$$ 
  cnt=0;
  for select
        f_id,
        f_value,
        f_good,
        f_count
      from
        t_nsi_scancode
      where
        f_id=:scan_id
      union
      select
        f_id,
        f_value,
        f_good,
        f_count
      from
        t_nsi_scancode
      where
        f_value=:f_scanvalue
      into
        :f_id,
        :f_value,
        :f_good,
        :f_count
      do
      begin
        if (coalesce(f_good,-1)>0) then
          select f_name from sp_t_nsi_goods_get(:f_good, null) into :f_goodname;
        cnt=cnt+1;
        suspend;
      end
      if (cnt=0) then
      begin
        f_id=GEN_ID(GEN_T_NSI_SCANCODE_ID,1);
        f_value=f_scanvalue;
        execute procedure SP_T_NSI_SCANCODE_I(:f_id,:f_value,null, null);
      end
 $$IBE$$*/ EXIT;
end^


CREATE OR ALTER PROCEDURE SP_CALC_INVENTORY (
    F_INVENTORY_ID BIGINT)
AS
DECLARE VARIABLE V_SKLAD BIGINT;
DECLARE VARIABLE V_INVENTORY_DATE DATE;
begin
  delete from t_inventory_str where f_inventory=:f_inventory_id;
  select f_sklad,f_date_start from t_inventory where f_id=:f_inventory_id into :v_sklad,:v_inventory_date;
    insert into t_inventory_str(f_good,f_inventory,f_count_plan,f_count_fact)
    select
      coalesce(r.f_good,dc.f_good),:f_inventory_id,f_end_ost,f_fact
    from
      SP_T_REG_GOOD_S(:v_sklad,:v_inventory_date,null) r
      left join
      (select k.f_good,sum(k.f_count) as f_fact from
        t_inventory_doc d
        inner join t_inventory_doc_str k on d.f_id=k.f_inventory_doc and d.f_inventory=:f_inventory_id
      group by k.f_good) dc on r.f_good=dc.f_good;

end^


CREATE OR ALTER PROCEDURE SP_CALC_PRICE (
    F_PRICE_ID BIGINT,
    F_START_DATE DATE)
AS
DECLARE VARIABLE F_PARENT BIGINT;
DECLARE VARIABLE F_DELTA FLOAT;
begin
  select f_parent_object,f_formula
  from t_nsi_price
  where
    f_id=:f_price_id
  into
    :f_parent,
    :f_delta;
  update t_price p set f_active=0 where
    f_id=:f_price_id
    and f_str_date=:f_start_date;
  if (f_parent>0) then
  begin
    EXECUTE PROCEDURE SP_CALC_PRICE_BY_PRICE(:f_parent, :f_start_date, :f_price_id, :f_delta);
  end
end^


CREATE OR ALTER PROCEDURE SP_CALC_PRICE_BY_DOC (
    DOC_ID BIGINT,
    START_DATE DATE,
    PRICE_ID BIGINT,
    CHACNGE_PRICE INTEGER)
AS
DECLARE VARIABLE F_GOOD BIGINT;
DECLARE VARIABLE F_CNT FLOAT;
DECLARE VARIABLE F_PRICE_VAL FLOAT;
begin
    for
      select
        s.f_good,
        sum(s.f_cnt),
        avg(s.f_price_val)
      from t_doc_in_str s
      where f_doc_in=:doc_id
      group by s.f_good
      into
        :f_good,
        :f_cnt,
        :f_price_val
    do
    begin
/*      f_price_id=GEN_ID(GEN_t_price_ID,1);
      update t_price set f_active=0 where f_good=:f_good and f_str_date=:start_date and f_active=1;
      insert into t_price (f_id,f_good,f_price,f_str_date,f_value,f_active,f_source)
        values(:f_price_id,:f_good,:price_id,:start_date,:f_price_val+:f_price_val*:chacnge_price/100,1,:doc_id);
*/
      execute procedure sp_t_price_i(:f_good,:price_id, :start_date,:f_price_val+:f_price_val*:chacnge_price/100);
--      update t_price set f_active=0 where f_id=:f_price_id;
    end
end^


CREATE OR ALTER PROCEDURE SP_CALC_PRICE_BY_PRICE (
    PARENT_ID BIGINT,
    START_DATE DATE,
    PRICE_ID BIGINT,
    CHACNGE_PRICE INTEGER)
AS
DECLARE VARIABLE F_ROUND_PRICE NUMERIC(15,3);
begin
  update t_price
  set f_active=0
  where f_price=:price_id and f_str_date<=:start_date and f_active=1;
  select f_round from t_nsi_price where f_id=:price_id into :f_round_price;
  insert into t_price(f_price,f_good,f_str_date,f_value,f_active)
  select
    :price_id,
    s.f_good,
    :start_date,
    (select f_result from sp_round((s.f_value+s.f_value*:chacnge_price/100),:f_round_price)),
    1
  from SP_T_PRICE_S(:parent_id) s;
end^


CREATE OR ALTER PROCEDURE SP_COPY_IN2MOVE (
    F_DOC_IN BIGINT)
RETURNS (
    F_MOVE_DOC BIGINT)
AS
DECLARE VARIABLE F_IN_ID BIGINT;
DECLARE VARIABLE F_SKLAD BIGINT;
DECLARE VARIABLE F_NUMBER VARCHAR(60);
DECLARE VARIABLE F_DATE DATE;
DECLARE VARIABLE F_GOOD BIGINT;
DECLARE VARIABLE F_PRICE_VAL NUMERIC(15,3);
DECLARE VARIABLE F_ID BIGINT;
DECLARE VARIABLE F_CNT NUMERIC(15,3);
begin
  if (f_doc_in is not null) then
  begin
    select
      F_ID,
      F_SKLAD,
      F_NUMBER,
      F_DATE,
      f_price
    from
      SP_T_DOC_IN_GET(:f_doc_in)
    into
      :f_in_id,
      :f_sklad,
      :f_number,
      :f_date,
      :f_id;

    select f_id from sp_t_doc_move_get(null) into :f_move_doc;
    for
      select
        f_good,
        f_price_val,
        f_cnt
      from sp_t_doc_in_str_s(:f_in_id)
      into
        :f_good,
        :f_price_val,
        :f_cnt
    do
    begin
      execute procedure SP_T_DOC_move_STR_I(null,:f_move_doc,:f_good,null,:f_cnt,:f_price_val);
    end
  end
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_COPY_IN2PRICE (
    F_DOC_IN BIGINT,
    F_CHANGE_PRICE INTEGER,
    F_PRICE BIGINT)
RETURNS (
    F_DOC_PRICE BIGINT)
AS
DECLARE VARIABLE F_IN_ID BIGINT;
DECLARE VARIABLE F_SKLAD BIGINT;
DECLARE VARIABLE F_NUMBER VARCHAR(60);
DECLARE VARIABLE F_DATE DATE;
DECLARE VARIABLE F_PRICE_ID BIGINT;
DECLARE VARIABLE F_GOOD BIGINT;
DECLARE VARIABLE F_PRICE_VAL NUMERIC(15,3);
DECLARE VARIABLE F_ROUND FLOAT;
DECLARE VARIABLE F_CURR_PRICE NUMERIC(15,3);
DECLARE VARIABLE F_ID BIGINT;
begin
  if (f_doc_in is not null) then
  begin
    select
      F_ID,
      F_SKLAD,
      F_NUMBER,
      F_DATE,
      f_price
    from
      SP_T_DOC_IN_GET(:f_doc_in)
    into
      :f_in_id,
      :f_sklad,
      :f_number,
      :f_date,
      :f_id;

    select f_id from sp_t_doc_price_get(null) into :f_price_id;
    f_id=coalesce(f_price,f_id);
    select f_round from SP_T_NSI_PRICE_GET(:f_id) into :f_round;
    update t_doc_price set f_num=:f_number, f_date=:f_date, f_parent=:f_in_id,f_price=:f_id,f_nacenka=:f_change_price where f_id=:f_price_id;
    for
      select
        f_good,
        f_price_val
      from sp_t_doc_in_str_s(:f_in_id)
      into
        :f_good,
        :f_price_val
    do
    begin
      f_curr_price=-1;
      select f_result from sp_round(:f_price_val*(cast((cast(:f_change_price as numeric(15,3))+cast(100 as numeric(15,3)))/cast(100 as numeric(15,3)) as numeric(15,3))),:f_round) into :f_price_val;
      select f_value from sp_t_price_get(:f_id,:f_good) into :f_curr_price;
      if (coalesce(f_curr_price,-1)<>f_price_val) then
        execute procedure SP_T_DOC_PRICE_STR_I(:f_good,:f_price_val,:f_price_id);
    end
    f_doc_price=f_price_id;
  end
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_COPY_PRICE2PRICE (
    P_SOURCE_PRICE BIGINT,
    P_PRICE BIGINT,
    P_CHANGE_PRICE NUMERIC(15,3),
    P_PARTNER_GOOD BIGINT)
AS
DECLARE VARIABLE V_ROUND FLOAT;
DECLARE VARIABLE V_PRICE_DOC BIGINT;
DECLARE VARIABLE V_CURR_PRICE NUMERIC(15,3);
DECLARE VARIABLE V_PRICE_VAL NUMERIC(15,3);
DECLARE VARIABLE V_GOOD BIGINT;
begin
    select f_id from sp_t_doc_price_get(null) into :v_price_doc;
    select f_round from SP_T_NSI_PRICE_GET(:p_source_price) into :v_round;
    update t_doc_price set f_num=f_id, f_date='now',f_price=:p_price ,f_nacenka=:p_change_price where f_id=:v_price_doc;
    for
        select f_id,(select f_value from SP_T_PRICE_GET(:p_source_price,g.f_id))
        from t_nsi_goods g where
            coalesce(f_partner,1)=coalesce(:p_partner_good,coalesce(g.f_partner,0))
        into :v_good,:v_curr_price
    do
    begin
      select f_result from sp_round(:v_curr_price*(cast((cast(:p_change_price as numeric(15,3))+cast(100 as numeric(15,3)))/cast(100 as numeric(15,3)) as numeric(15,3))),:v_round) into :v_price_val;
      if (v_curr_price<>v_price_val) then
        execute procedure SP_T_DOC_PRICE_STR_I(:v_good,:v_price_val,:v_price_doc);
     end
end^


CREATE OR ALTER PROCEDURE SP_DOC_OUT_CALC_SKIDKA (
    F_DOC_OUT INTEGER)
AS
DECLARE VARIABLE V_SKIDKA BIGINT;
DECLARE VARIABLE V_ROUND NUMERIC(15,3);
DECLARE VARIABLE V_SKIDKA_VAL NUMERIC(15,3);
begin
  select param_value from sp_get_sys_param('OUT_DOC_SKIDKA') into :V_SKIDKA;
  select f_round from t_nsi_skidka where f_id=:v_skidka into :v_round;
  select f_skidka from sp_t_doc_out_get(:f_doc_out) into :v_skidka_val;
    update t_doc_out_str
      set f_price_val=(f_price_val_nsi)*(100-coalesce(:v_skidka_val,0))/100.00
      where f_doc_out=:f_doc_out;
    --Округляем цену с учетом скидки
    update t_doc_out_str
      set f_price_val=(select f_result from sp_round(f_price_val,:v_round))
      where f_doc_out=:f_doc_out;
    update t_doc_out_str
      set f_price_val=f_price_val_nsi
      where f_doc_out=:f_doc_out and f_price_val_nsi<f_price_val;
end^


CREATE OR ALTER PROCEDURE SP_GET_GOOD_MOOVE (
    F_GOOD BIGINT,
    F_START_DATE DATE,
    F_END_DATE DATE)
RETURNS (
    F_DOC_ID BIGINT,
    F_DOC_DATE DATE,
    F_DOC_NUM VARCHAR(20),
    F_IN_CNT NUMERIC(15,3),
    F_OUT_CNT NUMERIC(15,3),
    F_IN_SUM NUMERIC(15,3),
    F_OUT_SUM NUMERIC(15,3),
    F_PARTNER VARCHAR(60),
    F_PARTNER_ID BIGINT)
AS
DECLARE VARIABLE F_SYS_ST BIGINT;
begin
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_st;
  select sum(r.f_end_ost) from t_reg_good r where r.f_good=:f_good and r.f_date=
    (select max(f_date) from t_reg_good g where g.f_good=r.f_good
      and g.f_sklad=r.f_sklad
      and g.f_date<:f_start_date)
  into :f_in_cnt;
  f_in_cnt=coalesce(f_in_cnt, 0);
  f_partner='Начальный остаток';
  suspend;
  for
    select f_id,f_date,f_number,f_in,f_out,f_isum,f_osum,f_partner
    from
    (
      select di.f_id,di.f_date,di.f_number,dis.f_cnt as f_in,cast(null as numeric(5,3)) as f_out,dis.f_price_val*dis.f_cnt as f_isum,cast(null as numeric(5,3)) as f_osum,di.f_partner
      from
        t_doc_in di
        inner join t_doc_in_str dis on di.f_id=dis.f_doc_in and dis.f_good=:f_good
      where
        di.f_date between :f_start_date and :f_end_date
        and di.f_state>=:f_sys_st
      union all
      select di.f_id,di.f_date,di.f_number,cast(null as numeric(5,3)) as f_in,dis.f_cnt as f_out,cast(null as numeric(5,3)) as f_isum,dis.f_price_val*dis.f_cnt as f_osum,di.f_partner
      from
        t_doc_out di
        inner join t_doc_out_str dis on di.f_id=dis.f_doc_out and dis.f_good=:f_good
      where
        di.f_date between :f_start_date and :f_end_date
        and di.f_state>=:f_sys_st
    )k
    order by f_date
    into
    :f_doc_id,
    :f_doc_date,
    :f_doc_num,
    :f_in_cnt,
    :f_out_cnt,
    :f_in_sum,
    :f_out_sum,
    :f_partner_id
  do
  begin
    if (f_partner_id is not null) then
    begin
      select f_name from sp_t_nsi_partner_get(:f_partner_id) into :f_partner;
    end
    else
      f_partner=null;
    suspend;
  end
end^


CREATE OR ALTER PROCEDURE SP_GET_GOOD_MOOVE_BY_STOCK (
    F_GOOD BIGINT,
    F_START_DATE DATE,
    F_END_DATE DATE,
    F_SKLAD BIGINT)
RETURNS (
    F_DOC_ID BIGINT,
    F_DOC_DATE DATE,
    F_DOC_NUM VARCHAR(20),
    F_IN_CNT NUMERIC(15,3),
    F_OUT_CNT NUMERIC(15,3),
    F_IN_SUM NUMERIC(15,3),
    F_OUT_SUM NUMERIC(15,3),
    F_PARTNER VARCHAR(60),
    F_PARTNER_ID BIGINT)
AS
DECLARE VARIABLE F_SYS_ST BIGINT;
begin
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_st;
  select sum(r.f_end_ost) from t_reg_good r where r.f_good=:f_good
    and r.f_sklad=:f_sklad
    and r.f_date=
    (select max(f_date) from t_reg_good g where g.f_good=r.f_good
      and g.f_sklad=r.f_sklad
      and g.f_date<:f_start_date)
  into :f_in_cnt;
  f_in_cnt=coalesce(f_in_cnt, 0);
  f_partner='Начальный остаток';
  suspend;
  for
    select f_id,f_date,f_number,f_in,f_out,f_isum,f_osum,f_partner,f_name
    from
    (
      select di.f_id,di.f_date,di.f_number,dis.f_cnt as f_in,cast(null as numeric(5,3)) as f_out,dis.f_price_val*dis.f_cnt as f_isum,cast(null as numeric(5,3)) as f_osum,di.f_partner,p.f_name
      from
        t_doc_in di
        inner join t_doc_in_str dis on di.f_id=dis.f_doc_in and dis.f_good=:f_good and di.f_sklad=:f_sklad
        left join t_nsi_partner p on di.f_partner=p.f_id
      where
        di.f_date between :f_start_date and :f_end_date
        and di.f_state>=:f_sys_st
      union all
      select di.f_id,di.f_date,di.f_number,cast(null as numeric(5,3)) as f_in,dis.f_cnt as f_out,cast(null as numeric(5,3)) as f_isum,dis.f_price_val*dis.f_cnt as f_osum,di.f_partner,p.f_name
      from
        t_doc_out di
        inner join t_doc_out_str dis on di.f_id=dis.f_doc_out and dis.f_good=:f_good and di.f_sklad=:f_sklad
        left join t_nsi_partner p on di.f_partner=p.f_id
      where
        di.f_date between :f_start_date and :f_end_date
        and di.f_state>=:f_sys_st
      union all
      select di.f_id,di.f_date,di.f_number,dis.f_cnt as f_in,cast(null as numeric(5,3)) as f_out,dis.f_price_val*dis.f_cnt as f_isum,cast(null as numeric(5,3)) as f_osum,null,p.f_name
      from
        t_doc_move di
        inner join t_doc_move_str dis on di.f_id=dis.f_doc_move and dis.f_good=:f_good and di.f_sklad_to=:f_sklad
        left join t_nsi_sklad p on di.f_sklad_from=p.f_id
      where
        di.f_date between :f_start_date and :f_end_date
        and di.f_state>=:f_sys_st
      union all
      select di.f_id,di.f_date,di.f_number,cast(null as numeric(5,3)) as f_in,dis.f_cnt as f_out,dis.f_price_val*dis.f_cnt as f_isum,cast(null as numeric(5,3)) as f_osum,null,p.f_name
      from
        t_doc_move di
        inner join t_doc_move_str dis on di.f_id=dis.f_doc_move and dis.f_good=:f_good and di.f_sklad_from=:f_sklad
        left join t_nsi_sklad p on di.f_sklad_to=p.f_id

      where
        di.f_date between :f_start_date and :f_end_date
        and di.f_state>=:f_sys_st

    )k
    order by f_date
    into
    :f_doc_id,
    :f_doc_date,
    :f_doc_num,
    :f_in_cnt,
    :f_out_cnt,
    :f_in_sum,
    :f_out_sum,
    :f_partner_id,
    :f_partner
  do
  begin
    suspend;
  end
end^


CREATE OR ALTER PROCEDURE SP_GET_IN_BY_PERIOD (
    F_STR_DATE DATE,
    F_END_DATE DATE)
RETURNS (
    F_GOOD BIGINT,
    F_GOOD_ARTICLE VARCHAR(20),
    F_GOOD_NAME VARCHAR(255),
    F_GOOD_ED_IZM VARCHAR(60),
    F_PARTNER BIGINT,
    F_PARTNER_NAME VARCHAR(255),
    F_NUM_OUT VARCHAR(20),
    F_DATE_OUT DATE,
    F_CNT NUMERIC(15,3),
    F_SUM NUMERIC(15,3),
    F_PRICE NUMERIC(15,3))
AS
DECLARE VARIABLE F_SYS_STATE BIGINT;
begin
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_state;
  for select
    d.f_number,
    d.f_date,
    d.f_partner,
    s.f_good,
    s.f_cnt,
    s.f_price_val,
    s.f_sum
  from
    t_doc_in d
    inner join t_doc_in_str s on d.f_id=s.f_doc_in
  where
   d.f_date between :f_str_date and :f_end_date
   and d.f_state>=:f_sys_state
  into
    :f_num_out,
    :f_date_out,
    :f_partner,
    :f_good,
    :f_cnt,
    :f_price,
    :f_sum
  do
  begin
    select f_name,f_article,f_ed_izm_name from sp_t_nsi_goods_get(:f_good,null)
      into :f_good_name,:f_good_article,:f_good_ed_izm;
    select f_name from sp_t_nsi_partner_get(:f_partner) into :f_partner_name;
    suspend;
  end
end^


CREATE OR ALTER PROCEDURE SP_GET_OUT_BY_PERIOD (
    F_STR_DATE DATE,
    F_END_DATE DATE)
RETURNS (
    F_GOOD BIGINT,
    F_GOOD_ARTICLE VARCHAR(20),
    F_GOOD_NAME VARCHAR(255),
    F_GOOD_ED_IZM VARCHAR(60),
    F_PARTNER BIGINT,
    F_PARTNER_NAME VARCHAR(255),
    F_NUM_OUT VARCHAR(20),
    F_DATE_OUT DATE,
    F_CNT NUMERIC(15,3),
    F_SUM NUMERIC(15,3),
    F_PRICE NUMERIC(15,3),
    F_INPUT_PRICE NUMERIC(15,3),
    F_INPUT_SUM NUMERIC(15,3))
AS
DECLARE VARIABLE F_IN_PRICE BIGINT;
DECLARE VARIABLE F_SYS_STATE BIGINT;
begin
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_state;
  select param_value from sp_get_sys_param('DEFAULT_IN_PRICE') into :f_in_price;
  for select
    d.f_number,
    d.f_date,
    d.f_partner,
    s.f_good,
    s.f_cnt,
    s.f_price_val,
    s.f_sum
  from
    t_doc_out d
    inner join t_doc_out_str s on d.f_id=s.f_doc_out
  where
   d.f_date between :f_str_date and :f_end_date
   and d.f_state>=:f_sys_state
  into
    :f_num_out,
    :f_date_out,
    :f_partner,
    :f_good,
    :f_cnt,
    :f_price,
    :f_sum
  do
  begin
    select f_name,f_article,f_ed_izm_name from sp_t_nsi_goods_get(:f_good,null)
      into :f_good_name,:f_good_article,:f_good_ed_izm;
    select f_name from sp_t_nsi_partner_get(:f_partner) into :f_partner_name;
    if (f_in_price>0) then
    begin
      select f_value from sp_t_price_get(:f_in_price,:f_good) into :f_input_price;
      f_input_sum=f_input_price*f_cnt;
    end
    else
    begin
      f_input_price=null;
      f_input_sum=null;
    end
    suspend;
  end
end^


CREATE OR ALTER PROCEDURE SP_GET_OUT_BY_PERIOD_BY_SKLAD (
    F_STR_DATE DATE,
    F_END_DATE DATE,
    P_SKLAD BIGINT)
RETURNS (
    F_GOOD BIGINT,
    F_GOOD_ARTICLE VARCHAR(20),
    F_GOOD_NAME VARCHAR(255),
    F_GOOD_ED_IZM VARCHAR(60),
    F_CNT NUMERIC(15,3),
    F_SUM NUMERIC(15,3),
    F_PRICE NUMERIC(15,3),
    F_INPUT_PRICE NUMERIC(15,3),
    F_INPUT_SUM NUMERIC(15,3),
    F_SKIDKA_SUM NUMERIC(15,3),
    F_BACK_SUM NUMERIC(15,3),
    F_BACK_CNT NUMERIC(15,3))
AS
DECLARE VARIABLE F_IN_PRICE BIGINT;
DECLARE VARIABLE F_SYS_STATE BIGINT;
begin
  select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') into :f_sys_state;
  select param_value from sp_get_sys_param('DEFAULT_IN_PRICE') into :f_in_price;
  for
  select
    coalesce(sa.f_good,b.f_good),
    f_cnt_sale,
    f_price_sale,
    f_sum_sale,
    f_sum_skd,
    f_back_sum,
    f_back_cnt
  from
  (
  select
    s.f_good,
    sum(s.f_cnt) as f_cnt_sale,
    sum(s.f_sum)/sum(s.f_cnt) as f_price_sale,
    sum(s.f_sum) as f_sum_sale,
    sum((coalesce(s.f_price_val_nsi,s.f_price_val)-s.f_price_val)*s.f_cnt) as f_sum_skd
  from
    t_doc_out d
    inner join t_doc_out_str s on d.f_id=s.f_doc_out
  where
   d.f_date between :f_str_date and :f_end_date
   and d.f_state>=:f_sys_state
   and d.f_sklad=coalesce(:p_sklad,d.f_sklad)
  group by s.f_good
  ) sa
  full join
      (
    select
      s.f_good,
      sum(s.f_sum) as f_back_sum,
      sum(s.f_cnt) as f_back_cnt
    from
      t_doc_in d
      inner join t_doc_in_str s on d.f_id=s.f_doc_in and d.f_type=2
    where
     d.f_date between :f_str_date and :f_end_date
     and d.f_state>=:f_sys_state
     and d.f_sklad=coalesce(:p_sklad,d.f_sklad)
    group by s.f_good
    ) b
  on sa.f_good=b.f_good
  into
    :f_good,
    :f_cnt,
    :f_price,
    :f_sum,
    :f_skidka_sum,
    :f_back_sum,
    :f_back_cnt
  do
  begin
    select f_name,f_article,f_ed_izm_name from sp_t_nsi_goods_get(:f_good,null)
      into :f_good_name,:f_good_article,:f_good_ed_izm;
    if (f_in_price>0) then
    begin
      select f_value from sp_t_price_get(:f_in_price,:f_good) into :f_input_price;
      f_input_sum=f_input_price*f_cnt;
    end
    else
    begin
      f_input_price=null;
      f_input_sum=null;
    end
    suspend;
  end
end^


CREATE OR ALTER PROCEDURE SP_GET_SOURCE_FOR_PRICE
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60))
AS
begin
  for select p.f_id,p.f_name from t_nsi_price p
    union
      select -1,'Приход' from rdb$database
    into :f_id,:f_name do
  begin
    suspend;
  end
end^


CREATE OR ALTER PROCEDURE SP_GET_SYS_PARAM (
    PARAM_NAME VARCHAR(60))
RETURNS (
    PARAM_VALUE VARCHAR(60))
AS
begin
  select f_value from t_sys_params where f_name=upper(:param_name) into :param_value;
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_IMPORT_DOC_IN (
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_PARTNER BIGINT,
    F_EXT_BASE VARCHAR(20),
    F_EXT_ID VARCHAR(20),
    F_DOC_TYPE BIGINT)
RETURNS (
    F_ID BIGINT)
AS
begin
  select f_id from SP_T_DOC_IN_GET(null,:f_doc_type) into :f_id;
  insert into t_sys_links(f_table_name,f_remote_base,f_remote_id,f_self_id) values('T_DOC_IN',:f_ext_base,:f_ext_id,:f_id);
  if (not exists (select f_id from t_nsi_partner where f_id=:f_partner)) then
    f_partner=null;
  execute procedure sp_t_doc_in_u(:f_id,null, :f_partner,:f_number,:f_date,null,null);
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_IMPORT_DOC_IN_STR (
    F_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM VARCHAR(255),
    F_COUNT NUMERIC(15,3),
    F_PRICE NUMERIC(15,3),
    F_EXT_ID VARCHAR(20),
    F_EXT_BASE BIGINT,
    F_DOC_ID BIGINT)
RETURNS (
    F_GOOD_ID BIGINT,
    F_ID BIGINT)
AS
DECLARE VARIABLE F_IZM BIGINT;
begin
  f_good_id=0;
  if (exists(select first 1 f_id from t_nsi_goods where f_article=:f_article) ) then
  begin
    select first 1 f_id from t_nsi_goods where f_article=:f_article into :f_good_id;
  end

  if (not exists (select 1 from t_nsi_ed_izm where upper(f_name)=upper(:f_ed_izm))) then
  begin
    f_izm=GEN_ID(GEN_T_NSI_ED_IZM_ID,1);
    execute procedure SP_T_NSI_ED_IZM_I(:f_izm,:f_ed_izm,:f_ed_izm);
  end
  else
    select f_id from t_nsi_ed_izm where upper(f_name)=upper(:f_ed_izm) into :f_id;
  if (f_good_id<1) then
  begin
    select f_id
    from
      SP_T_NSI_GOODS_I(:f_name,null,:f_article,:f_izm)
    into :f_good_id;
    insert into t_sys_links(f_table_name,f_remote_base,f_remote_id,f_self_id) values('T_NSI_GOODS',:f_ext_base,:f_ext_id,:f_good_id);
  end
  execute procedure SP_T_DOC_IN_STR_I(null, :f_doc_id,:f_good_id,:f_price,:f_count,null);
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_IMPORT_DOC_MOVE (
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_SKLAD BIGINT,
    F_EXT_BASE VARCHAR(20),
    F_EXT_ID VARCHAR(20),
    F_DOC_TYPE BIGINT)
RETURNS (
    F_ID BIGINT)
AS
declare variable V_SELF_SKLAD bigint;
begin
  select f_id from SP_T_DOC_move_GET(null) into :f_id;
  insert into t_sys_links(f_table_name,f_remote_base,f_remote_id,f_self_id) values('T_DOC_MOVE',:f_ext_base,:f_ext_id,:f_id);
  select param_value from SP_GET_SYS_PARAM('default_sklad') into :v_self_sklad;
  execute procedure sp_t_doc_move_u(:f_id,:f_date,:f_number,:f_sklad,:v_self_sklad, null,null,null, null, null);
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_IMPORT_DOC_OUT (
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_PARTNER BIGINT,
    F_EXT_BASE VARCHAR(20),
    F_EXT_ID VARCHAR(20),
    F_DOC_TYPE BIGINT,
    F_SKLAD BIGINT)
RETURNS (
    F_ID BIGINT)
AS
begin
  select f_id from SP_T_DOC_out_GET(null,:f_doc_type,:f_sklad) into :f_id;
  insert into t_sys_links(f_table_name,f_remote_base,f_remote_id,f_self_id) values('T_DOC_out',:f_ext_base,:f_ext_id,:f_id);
  if (not exists (select f_id from t_nsi_partner where f_id=:f_partner)) then
    f_partner=null;
  execute procedure sp_t_doc_out_u(:f_id,:f_sklad, :f_partner,:f_number,:f_date,null,null,null,null);
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_IMPORT_DOC_OUT_STR (
    F_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM VARCHAR(255),
    F_COUNT NUMERIC(15,3),
    F_PRICE NUMERIC(15,3),
    F_SKIDKA NUMERIC(15,3),
    F_EXT_ID VARCHAR(20),
    F_EXT_BASE BIGINT,
    F_DOC_ID BIGINT)
RETURNS (
    F_GOOD_ID BIGINT,
    F_ID BIGINT)
AS
DECLARE VARIABLE F_IZM BIGINT;
DECLARE VARIABLE V_STR_ID BIGINT;
begin
  f_good_id=0;
  if (exists(select first 1 f_id from t_nsi_goods where f_article=:f_article) ) then
  begin
    select first 1 f_id from t_nsi_goods where f_article=:f_article into :f_good_id;
  end
  if (not exists (select 1 from t_nsi_ed_izm where upper(f_name)=upper(:f_ed_izm))) then
  begin
    f_izm=GEN_ID(GEN_T_NSI_ED_IZM_ID,1);
    execute procedure SP_T_NSI_ED_IZM_I(:f_izm,:f_ed_izm,:f_ed_izm);
  end
  else
    select f_id from t_nsi_ed_izm where upper(f_name)=upper(:f_ed_izm) into :f_id;
  if (f_good_id<1) then
  begin
    select f_id
    from
      SP_T_NSI_GOODS_I(:f_name,null,:f_article,:f_izm)
    into :f_good_id;
    insert into t_sys_links(f_table_name,f_remote_base,f_remote_id,f_self_id) values('T_NSI_GOODS',:f_ext_base,:f_ext_id,:f_good_id);
  end
  v_str_id=gEN_ID(gen_t_doc_out_str_id,1);
  execute procedure SP_T_DOC_out_STR_I(:v_str_id, :f_doc_id,:f_good_id,null,:f_count,null);
  update t_doc_out_str set f_price_val=:f_price,f_price_val_nsi=:f_price+coalesce(:f_skidka/:f_count,0) where f_id=:v_str_id;
  /*execute procedure SP_T_DOC_out_STR_u(:v_str_id,null, null,:f_price,null,null);
  update t_doc_out_str set f_price_val=:f_price where f_id=:v_str_id;*/
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_IMPORT_DOC_PRICE (
    F_NUMBER VARCHAR(20),
    F_PRICE BIGINT,
    F_DATE DATE)
RETURNS (
    F_ID BIGINT)
AS
DECLARE VARIABLE F_STATE BIGINT;
begin
  /* Procedure Text */
  f_id=GEN_ID(GEN_t_doc_price_ID,1);
  select param_value from SP_GET_SYS_PARAM('out_doc_state') into :f_state;
  execute procedure SP_T_DOC_PRICE_I(:f_id, :f_number,'now',null,:f_state,:f_price);
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_IMPORT_DOC_PRICE_STR (
    F_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM VARCHAR(255),
    F_PRICE NUMERIC(15,3),
    F_EXT_ID VARCHAR(20),
    F_EXT_BASE BIGINT,
    F_DOC_ID BIGINT)
RETURNS (
    F_GOOD_ID BIGINT,
    F_ID BIGINT)
AS
DECLARE VARIABLE F_IZM BIGINT;
begin
  f_good_id=0;
  if (exists(select first 1 f_id from t_nsi_goods where f_article=:f_article) ) then
  begin
    select first 1 f_id from t_nsi_goods where f_article=:f_article into :f_good_id;
  end

  if (not exists (select 1 from t_nsi_ed_izm where upper(f_name)=upper(:f_ed_izm))) then
  begin
    f_izm=GEN_ID(GEN_T_NSI_ED_IZM_ID,1);
    execute procedure SP_T_NSI_ED_IZM_I(:f_izm,:f_ed_izm,:f_ed_izm);
  end
  else
    select f_id from t_nsi_ed_izm where upper(f_name)=upper(:f_ed_izm) into :f_id;
  if (f_good_id<1) then
  begin
    select f_id
    from
      SP_T_NSI_GOODS_I(:f_name,null,:f_article,:f_izm)
    into :f_good_id;
    insert into t_sys_links(f_table_name,f_remote_base,f_remote_id,f_self_id) values('T_NSI_GOODS',:f_ext_base,:f_ext_id,:f_good_id);
  end

  execute procedure SP_T_DOC_PRICE_STR_I(:f_good_id,:f_price,:f_doc_id);
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_IMPORT_INVENTORY_DOC_STR (
    F_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM VARCHAR(255),
    F_COUNT NUMERIC(15,3),
    F_EXT_ID VARCHAR(20),
    F_EXT_BASE BIGINT,
    F_DOC_ID BIGINT)
RETURNS (
    F_GOOD_ID BIGINT,
    F_ID BIGINT)
AS
DECLARE VARIABLE F_IZM BIGINT;
DECLARE VARIABLE V_STR_ID BIGINT;
begin
  f_good_id=0;
  if (exists(select first 1 f_id from t_nsi_goods where f_article=:f_article) ) then
  begin
    select first 1 f_id from t_nsi_goods where f_article=:f_article into :f_good_id;
  end
  if (not exists (select 1 from t_nsi_ed_izm where upper(f_name)=upper(:f_ed_izm))) then
  begin
    f_izm=GEN_ID(GEN_T_NSI_ED_IZM_ID,1);
    execute procedure SP_T_NSI_ED_IZM_I(:f_izm,:f_ed_izm,:f_ed_izm);
  end
  else
    select f_id from t_nsi_ed_izm where upper(f_name)=upper(:f_ed_izm) into :f_id;
  if (f_good_id<1) then
  begin
    select f_id
    from
      SP_T_NSI_GOODS_I(:f_name,null,:f_article,:f_izm)
    into :f_good_id;
    insert into t_sys_links(f_table_name,f_remote_base,f_remote_id,f_self_id) values('T_NSI_GOODS',:f_ext_base,:f_ext_id,:f_good_id);
  end
  v_str_id=gEN_ID(gen_t_inventory_doc_str_id,1);
  execute procedure SP_T_inventory_doc_STR_I(:v_str_id,:f_good_id,:f_count,:f_doc_id);
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_IMPORT_NSI_GOOD (
    F_ID BIGINT,
    F_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_PARTNER BIGINT,
    F_EXT_BASE BIGINT)
RETURNS (
    F_GOOD_ID BIGINT)
AS
begin
  f_good_id=0;
  if (exists(select first 1 f_id from t_nsi_goods where f_article=:f_article) ) then
  begin
    select first 1 f_id from t_nsi_goods where f_article=:f_article into :f_good_id;
  end
  if (f_good_id<1) then
  begin
    select f_id
    from
      SP_T_NSI_GOODS_I(:f_name,null,:f_article,null)
    into :f_good_id;
    insert into t_sys_links(f_table_name,f_remote_base,f_remote_id,f_self_id) values('T_NSI_GOODS',:f_ext_base,:f_id,:f_good_id);
  end
  if (exists (select f_id from t_nsi_partner where f_id=:f_partner)) then
    update t_nsi_goods set f_partner=:f_partner where f_id=:f_good_id;
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_IMPORT_NSI_PARTNER (
    F_NAME VARCHAR(60),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20),
    F_ADDRESS VARCHAR(255),
    F_EXT_BASE VARCHAR(20),
    F_EXT_ID VARCHAR(20))
RETURNS (
    F_ID BIGINT)
AS
begin
  f_id=null;
  select first 1 f_id
  from
  (
    select f_id
    from
      t_nsi_partner
    where
      f_name=upper(:f_name)
      and trim(coalesce(f_name,''))<>''
    union
    select f_id
    from
      t_nsi_partner
    where
      f_inn=:f_inn
      and trim(coalesce(f_inn,''))<>''
/*    union
    select f_self_id
    from
      t_sys_links s
    where
      f_table_name='T_NSI_PARTNER'
      and s.f_remote_id=:f_ext_id*/
    )
    into :f_id;
  if ((f_id is null) and (trim(coalesce(f_inn,''))<>'') and (trim(coalesce(f_name,''))<>'')) then
  begin
    f_id=GEN_ID(GEN_t_nsi_partner_ID,1);
    execute procedure sp_t_nsi_partner_i(:f_id,:f_name,:f_name,:f_address,:f_inn,:f_kpp);
    insert into t_sys_links(f_table_name,f_remote_base,f_remote_id,f_self_id) values('T_NSI_PARTNER',:f_ext_base,:f_ext_id,:f_id);
  end
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_IMPORT_NSI_PRICE (
    F_PRICE_ID BIGINT,
    F_PRICE_NAME VARCHAR(60))
RETURNS (
    F_ID BIGINT)
AS
begin
  if (not exists(select f_id from t_nsi_price  where f_name=:f_price_name)) then
  begin
    f_id=GEN_ID(GEN_t_nsi_price_ID,1);
    insert into t_nsi_price(f_id,f_name) values (:f_id,:f_price_name);
    suspend;
  end
  else
  begin
    select f_id from t_nsi_price where f_name=:f_price_name into :f_id;
    suspend;
  end
end^


CREATE OR ALTER PROCEDURE SP_IMPORT_NSI_SCANCODE (
    F_GOOD BIGINT,
    F_SCANCODE VARCHAR(20))
RETURNS (
    F_RESULT SMALLINT)
AS
begin
/*    if (exists (select 1 from t_nsi_scancode where f_value=:f_scancode and f_good<>:f_good)) then
    begin
      f_result=-1;
    end
    else
    begin*/
      if (not exists (select 1 from SP_T_NSI_SCANCODE_GET(:f_good) where f_value=:f_scancode)) then
        execute procedure SP_T_NSI_SCANCODE_I(null,:f_scancode,:f_good,1);
      f_result=1;
 --   end
    suspend;
end^


CREATE OR ALTER PROCEDURE SP_INVENTORY_MAKE_DOCS_BY_REZ (
    F_INVENTORY_ID BIGINT)
AS
DECLARE VARIABLE V_MOVE_IN_DOC BIGINT;
DECLARE VARIABLE V_MOVE_OUT_DOC BIGINT;
DECLARE VARIABLE V_SKLAD BIGINT;
DECLARE VARIABLE V_DATE DATE;
begin
  select coalesce(f_date_complete,'now'),f_sklad from t_inventory where f_id=:f_inventory_id
    into :v_date,:v_sklad;
  if (exists (select f_id from t_inventory_str where f_inventory=:f_inventory_id and coalesce(f_count_plan,0)>coalesce(f_count_fact,0))) then
  begin

    select f_Id from SP_T_DOC_MOVE_GET(null) into :v_move_out_doc;
    update t_doc_move set f_type=2,
      f_sklad_to=null,f_sklad_from=:v_sklad,f_date=:v_date where f_id=:v_move_out_doc;
    insert into t_doc_move_str(f_doc_move,f_good,f_cnt)
    select :v_move_out_doc,f_good,(coalesce(f_count_plan,0)-coalesce(f_count_fact,0))
      from t_inventory_str where f_inventory=:f_inventory_id and coalesce(f_count_plan,0)>coalesce(f_count_fact,0);
  end

  if (exists (select f_id from t_inventory_str where f_inventory=:f_inventory_id and coalesce(f_count_plan,0)<coalesce(f_count_fact,0))) then
  begin
    select f_Id from SP_T_DOC_MOVE_GET(null) into :v_move_in_doc;
    update t_doc_move set f_type=3,
      f_sklad_from=null,f_sklad_to=:v_sklad,f_date=:v_date where f_id=:v_move_in_doc;
    insert into t_doc_move_str(f_doc_move,f_good,f_cnt)
    select :v_move_in_doc,f_good,(coalesce(f_count_fact,0)-coalesce(f_count_plan,0))
      from t_inventory_str where f_inventory=:f_inventory_id and coalesce(f_count_plan,0)<coalesce(f_count_fact,0);
  end
end^


CREATE OR ALTER PROCEDURE SP_MONEY_IN_AUTO (
    F_MONEY BIGINT,
    F_SUM NUMERIC(15,3) = -1)
AS
DECLARE VARIABLE V_PAY_SUM NUMERIC(15,3);
DECLARE VARIABLE V_DOC_OUT BIGINT;
DECLARE VARIABLE V_PARTNER BIGINT;
DECLARE VARIABLE V_DOC_SUM NUMERIC(15,3);
begin
  select
    f_partner,
    case
      when :f_sum>1 then :f_sum
      else (f_summa-coalesce(f_doc_sum,0))
    end
  from sp_t_money_in_get(:f_money,null) into :v_partner,:v_pay_sum;
  for
    select
      f_id,
      f_doc_sum-coalesce(f_pay_sum,0)
    from
      t_doc_out
    where
      (f_doc_sum-coalesce(f_pay_sum,0))>0 and
      f_partner=:v_partner
    order by
      f_date
    into
      :v_doc_out,
      :v_doc_sum
  do
  begin
    if (v_doc_sum>v_pay_sum) then
    begin
      v_doc_sum=v_pay_sum;
      v_pay_sum=0;
    end
    else
      v_pay_sum=v_pay_sum-v_doc_sum;
    --f_pay=v_pay_sum;
    --suspend;
    if (v_doc_sum>0) then
      execute procedure SP_T_MONEY_IN_STR_I(null, :v_doc_out,:f_money,:v_doc_sum);
    if (v_pay_sum=0) then
      exit;
  end
end^


CREATE OR ALTER PROCEDURE SP_ROUND (
    F_VALUE FLOAT,
    F_RND FLOAT)
RETURNS (
    F_RESULT NUMERIC(10,3))
AS
DECLARE VARIABLE I NUMERIC(10,3);
DECLARE VARIABLE J BIGINT;
DECLARE VARIABLE N BIGINT;
DECLARE VARIABLE CNT INTEGER;
DECLARE VARIABLE K BIGINT;
DECLARE VARIABLE P NUMERIC(10,3);
begin
  f_result=0;
  cnt=1;
  k=cast(f_rnd as integer);
  p=f_rnd;
  while (k<>p) do
  begin
    cnt=cnt*10;
    p=p*10;
    k=p;
  end
  J=f_value*cnt;
  I=J/p;
  N=J/p;
  while (N<>I) do
  begin
    J=J+1;
    I=J/p;
    N=J/p;
  end
  f_result=cast(J as numeric(10,3))/cnt;
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_SET_PRICE_FROM_NSI (
    F_PRICE BIGINT,
    F_DOC BIGINT)
AS
DECLARE VARIABLE GOOD_ID BIGINT;
DECLARE VARIABLE DOC_STR_ID BIGINT;
DECLARE VARIABLE PRICE_VAL NUMERIC(15,3);
begin
  for
  select
    f_id,
    f_good
  from sp_t_doc_in_str_s(:f_doc)
  into
    :doc_str_id,
    :good_id do
  begin
    price_val=0;
    select f_value from sp_t_price_get(:f_price,:good_id) into :price_val;
    if (coalesce(price_val,0)>0) then
      update t_doc_in_str set f_price_val=:price_val where f_id=:doc_str_id;
  end
end^


CREATE OR ALTER PROCEDURE SP_SET_SYS_PARAM (
    PARAM_NAME VARCHAR(60),
    PARAM_VALUE VARCHAR(60))
AS
begin
  if (exists (select 1 from t_sys_params where f_name=upper(:param_name))) then
      update t_sys_params set f_value=:param_value where f_name=upper(:param_name);
  else
      insert into t_sys_params(f_name,f_value) values (upper(:param_name),:param_value);
end^


CREATE OR ALTER PROCEDURE SP_T_DOC_IN_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_DOC_IN
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_IN_GET (
    DOC_ID BIGINT,
    DOC_TYPE BIGINT = 0)
RETURNS (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(60),
    F_DATE DATE,
    F_STATE BIGINT,
    F_PARTNER_NAME VARCHAR(60),
    F_PARTNER_KPP VARCHAR(20),
    F_PARTNER_INN VARCHAR(20),
    F_STATE_NAME VARCHAR(60),
    F_SKLAD_NAME VARCHAR(60),
    F_SKLAD_INN VARCHAR(20),
    F_SKLAD_F_NAME VARCHAR(100),
    F_SKLAD_KPP VARCHAR(20),
    F_PRICE BIGINT,
    F_PRICE_NAME VARCHAR(60),
    F_DOC_TYPE BIGINT,
    F_DOC_SUM NUMERIC(15,3))
AS
begin
  if (coalesce(doc_id,-1) < 1 ) then
  begin
    f_id=GEN_ID(GEN_t_doc_in_ID,1);
    select param_value from SP_GET_SYS_PARAM('default_sklad') into :f_sklad;
    f_date='now';
    select param_value from SP_GET_SYS_PARAM('in_doc_state') into :f_state;
    select param_value from SP_GET_SYS_PARAM('default_in_price') into :f_price;
    if (doc_type < 1) then
      select param_value from SP_GET_SYS_PARAM('IN_DOC_TYPE') into :f_doc_type;
    else
      f_doc_type=doc_type;
    select f_name,coalesce(f_price_in,:f_price) from sp_t_nsi_sklad_get(:f_sklad) into :f_sklad_name,:f_price;
    select f_name from sp_t_nsi_price_get(:f_price) into :f_price_name;
    f_number=f_id;
    execute procedure sp_t_doc_in_i(:f_id,:f_sklad,null,:f_number,:f_date,:f_state,:f_price,:f_doc_type);
  end
  else
  begin
    select
        f_id, 
        f_sklad, 
        f_partner, 
        f_number, 
        f_date, 
        f_state,
        f_price,
        f_type,
        f_doc_sum
    from
        t_doc_in
    where
        f_id=:doc_id
    into
        :f_id,
        :f_sklad,
        :f_partner,
        :f_number,
        :f_date,
        :f_state,
        :f_price,
        :f_doc_type,
        :f_doc_sum;
    if (coalesce(f_partner,-1)>0) then
      select f_name,f_inn,f_kpp from sp_t_nsi_partner_get(:f_partner) into :f_partner_name,:f_partner_inn,:f_partner_kpp;
    if (coalesce(f_sklad,-1)>0) then
      select f_name,f_partner_kpp,f_partner_inn,f_partner_name
        from sp_t_nsi_sklad_get(:f_sklad) into :f_sklad_name,:f_sklad_kpp,:f_sklad_inn,:f_sklad_f_name;
    if (coalesce(f_price,-1)>0) then
      select f_name from sp_t_nsi_price_get(:f_price) into :f_price_name;
  end
  select f_name from SP_T_NSI_STATE_get(:f_state) into :f_state_name;
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_T_DOC_IN_I (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(60),
    F_DATE DATE,
    F_STATE BIGINT,
    F_PRICE BIGINT,
    F_DOC_TYPE BIGINT)
AS
BEGIN
  INSERT INTO T_DOC_IN (
    F_ID,
    F_SKLAD,
    F_PARTNER,
    F_NUMBER,
    F_DATE,
    F_STATE,
    f_price,
    f_type)
  VALUES (
    :F_ID,
    :F_SKLAD,
    :F_PARTNER,
    :F_NUMBER,
    :F_DATE,
    :F_STATE,
    :f_price,
    :f_doc_type);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_IN_S (
    P_DOC_TYPE BIGINT = -1)
RETURNS (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(60),
    F_DATE DATE,
    F_STATE BIGINT,
    F_DOC_COUNT FLOAT,
    F_DOC_SUM NUMERIC(15,3),
    F_SKLAD_NAME VARCHAR(60),
    F_PARTNER_NAME VARCHAR(60),
    F_STATE_NAME VARCHAR(60),
    F_DOC_TYPE BIGINT,
    F_DOC_TYPE_NAME VARCHAR(60))
AS
BEGIN
  FOR SELECT F_ID,
             F_SKLAD,
             F_PARTNER,
             F_NUMBER,
             F_DATE,
             F_STATE,
             f_doc_count,
             f_doc_sum,
             f_type
      FROM T_DOC_IN
      where
        f_type=:p_doc_type
        or coalesce(:p_doc_type,-1)<0
      INTO :F_ID,
           :F_SKLAD,
           :F_PARTNER,
           :F_NUMBER,
           :F_DATE,
           :F_STATE,
           :f_doc_count,
           :f_doc_sum,
           :f_doc_type
  DO
  BEGIN
    if (coalesce(f_partner,-1)>0) then
        select f_name from sp_t_nsi_partner_get(:f_partner) into :f_partner_name;
    else
        f_partner_name=null;
    if (coalesce(f_state,-1)>0) then
        select f_name from sp_t_nsi_state_get(:f_state) into :f_state_name;
    else
        f_state_name=null;
    if (coalesce(f_sklad,-1)>0) then
        select f_name from sp_t_nsi_sklad_get(:f_sklad) into :f_sklad_name;
    else
        f_sklad_name=null;
    select f_name from SP_T_NSI_DOC_IN_TYPES_GET(:f_doc_type) into :f_doc_type_name;
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_IN_STR_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_DOC_IN_STR
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_IN_STR_I (
    F_ID BIGINT,
    F_DOC_IN BIGINT,
    F_GOOD BIGINT,
    F_PRICE_VAL FLOAT,
    F_CNT FLOAT,
    F_SUM FLOAT)
AS
DECLARE VARIABLE V_PRICE_ID BIGINT;
BEGIN
  if (exists(select 1 from t_doc_in where f_id=:f_doc_in)) then
  begin
    select f_price from sp_t_doc_in_get(:f_doc_in,null) into :v_price_id;
    if (F_PRICE_val is null) then
      select f_value from SP_T_PRICE_GET(:v_price_id,:f_good) into :F_PRICE_val;

  end
  if (exists(select 1 from T_DOC_in_STR where
      f_doc_in=:F_DOC_in and F_GOOD=:F_GOOD)) then
  begin
    update T_DOC_in_STR
    set F_CNT=F_CNT+coalesce(:F_CNT,1)
    where f_doc_in=:F_DOC_in and F_GOOD=:F_GOOD;
  end
  else
  begin
    INSERT INTO T_DOC_IN_STR (
      F_ID,
      F_DOC_IN,
      F_GOOD,
      F_PRICE_val,
      F_CNT)
    VALUES (
      :F_ID,
      :F_DOC_IN,
      :F_GOOD,
      :F_PRICE_val,
      coalesce(:F_CNT,1));
  end
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_IN_STR_S (
    DOC_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC_IN BIGINT,
    F_GOOD BIGINT,
    F_PRICE_VAL FLOAT,
    F_CNT FLOAT,
    F_SUM FLOAT,
    F_GOOD_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_SCANCODE VARCHAR(60),
    F_GOOD_DOP_INFO VARCHAR(255),
    F_GOOD_PARTNER BIGINT)
AS
BEGIN
  FOR SELECT F_ID,
             F_DOC_IN,
             F_GOOD,
             F_PRICE_val,
             F_CNT,
             F_SUM
      FROM T_DOC_IN_STR
      where
        f_doc_in=:doc_id
      INTO :F_ID,
           :F_DOC_IN,
           :F_GOOD,
           :F_PRICE_val,
           :F_CNT,
           :F_SUM
  DO
  BEGIN
    if (coalesce(f_good,-1)>0) then
      select f_name,f_article,f_ed_izm_name,f_ed_izm_short_name,f_scancode,f_dop_info,f_partner from sp_t_nsi_goods_get(:f_good,null)
        into :f_good_name,:f_article,:f_ed_izm_name,:f_ed_izm_short_name,:f_scancode,:f_good_dop_info,:f_good_partner;
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_IN_STR_S_BY_CNT (
    DOC_ID BIGINT,
    CNT BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC_IN BIGINT,
    F_GOOD BIGINT,
    F_PRICE_VAL FLOAT,
    F_CNT FLOAT,
    F_SUM FLOAT,
    F_GOOD_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_SCANCODE VARCHAR(60),
    F_GOOD_DOP_INFO VARCHAR(255))
AS
DECLARE VARIABLE DOC_CNT INTEGER;
BEGIN
  FOR SELECT F_ID,
             F_DOC_IN,
             F_GOOD,
             F_PRICE_val,
             F_CNT,
             F_SUM
      FROM T_DOC_IN_STR
      where
        f_doc_in=:doc_id
      INTO :F_ID,
           :F_DOC_IN,
           :F_GOOD,
           :F_PRICE_val,
           :F_CNT,
           :F_SUM
  DO
  BEGIN
    doc_cnt=0;
    if (coalesce(f_good,-1)>0) then
      select f_name,f_article,f_ed_izm_name,f_ed_izm_short_name,f_scancode,f_dop_info from sp_t_nsi_goods_get(:f_good,null)
        into :f_good_name,:f_article,:f_ed_izm_name,:f_ed_izm_short_name,:f_scancode,:f_good_dop_info;
    doc_cnt=coalesce(cnt,F_CNT);
    while (doc_cnt>0) do
    begin
      SUSPEND;
      doc_cnt=doc_cnt-1;
    end
  END
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_IN_STR_U (
    F_ID BIGINT,
    F_DOC_IN BIGINT,
    F_GOOD BIGINT,
    F_PRICE_VAL FLOAT,
    F_CNT FLOAT,
    F_SUM FLOAT)
AS
BEGIN
  UPDATE T_DOC_IN_STR
  SET F_DOC_IN = :F_DOC_IN,
      F_GOOD = :F_GOOD,
      F_PRICE_val = :F_PRICE_val,
      F_CNT = :F_CNT
--      F_SUM = :F_SUM
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_IN_U (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(60),
    F_DATE DATE,
    F_STATE BIGINT,
    F_PRICE BIGINT)
AS
BEGIN
  UPDATE T_DOC_IN
  SET F_SKLAD = coalesce(:F_SKLAD,f_sklad),
      F_PARTNER = coalesce(:F_PARTNER,f_partner),
      F_NUMBER = coalesce(:F_NUMBER,f_number),
      F_DATE = coalesce(:F_DATE,f_date),
      F_STATE = coalesce(:F_STATE,f_state),
      f_price = coalesce(:f_price,f_price)
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_DOC_MOVE
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_GET (
    DOC_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_SKLAD_FROM BIGINT,
    F_SKLAD_TO BIGINT,
    F_NUMBER VARCHAR(60),
    F_DATE DATE,
    F_STATE BIGINT,
    F_STATE_NAME VARCHAR(60),
    F_SKLAD_FROM_NAME VARCHAR(60),
    F_SKLAD_FROM_INN VARCHAR(20),
    F_SKLAD_FROM_F_NAME VARCHAR(100),
    F_SKLAD_FROM_KPP VARCHAR(20),
    F_SKLAD_TO_NAME VARCHAR(60),
    F_SKLAD_TO_INN VARCHAR(20),
    F_SKLAD_TO_F_NAME VARCHAR(100),
    F_SKLAD_TO_KPP VARCHAR(20),
    F_PRICE BIGINT,
    F_PRICE_NAME VARCHAR(60),
    F_DOC_SUM NUMERIC(15,3),
    F_TYPE BIGINT)
AS
begin
  if (coalesce(doc_id,-1) < 1 ) then
  begin
    f_id=GEN_ID(GEN_t_doc_move_ID,1);
    select param_value from SP_GET_SYS_PARAM('default_sklad') into :f_sklad_from;
    f_date='now';
    select param_value from SP_GET_SYS_PARAM('move_doc_state') into :f_state;
    select param_value from SP_GET_SYS_PARAM('MOVE_DOC_TYPE') into :f_type;
    select param_value from SP_GET_SYS_PARAM('default_in_price') into :f_price;
    select f_name,coalesce(f_price_out,:f_price) from sp_t_nsi_sklad_get(:f_sklad_from) into :f_sklad_from_name,:f_price;
    select f_name from sp_t_nsi_price_get(:f_price) into :f_price_name;
    f_number=f_id;
    execute procedure sp_t_doc_move_i(:f_id,:f_date, :f_number,:f_sklad_from,null,:f_state,null,:f_price,:f_type,null);
  end
  else
  begin
    select
        f_id, 
        f_sklad_from,
        f_sklad_to,
        f_number,
        f_date, 
        f_state,
        f_price,
        f_doc_sum
    from
        t_doc_move
    where
        f_id=:doc_id
    into
        :f_id,
        :f_sklad_from,
        :f_sklad_to,
        :f_number,
        :f_date,
        :f_state,
        :f_price,
        :f_doc_sum;
    if (coalesce(f_sklad_from,-1)>0) then
      select f_name,f_partner_kpp,f_partner_inn,f_partner_name
        from sp_t_nsi_sklad_get(:f_sklad_from) into :f_sklad_from_name,:f_sklad_from_kpp,:f_sklad_from_inn,:f_sklad_from_f_name;
    else
    begin
      f_sklad_from_name=null;
      f_sklad_from_kpp=null;
      f_sklad_from_inn=null;
      f_sklad_from_f_name=null;
    end
    if (coalesce(f_sklad_to,-1)>0) then
      select f_name,f_partner_kpp,f_partner_inn,f_partner_name
        from sp_t_nsi_sklad_get(:f_sklad_to) into :f_sklad_to_name,:f_sklad_to_kpp,:f_sklad_to_inn,:f_sklad_to_f_name;
    else
    begin
      f_sklad_to_name=null;
      f_sklad_to_kpp=null;
      f_sklad_to_inn=null;
      f_sklad_to_f_name=null;
    end
    if (coalesce(f_price,-1)>0) then
      select f_name from sp_t_nsi_price_get(:f_price) into :f_price_name;
    else
      f_price_name=null;
  end
  select f_name from SP_T_NSI_STATE_get(:f_state) into :f_state_name;
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_I (
    F_ID BIGINT,
    F_DATE DATE,
    F_NUMBER VARCHAR(20),
    F_SKLAD_FROM BIGINT,
    F_SKLAD_TO BIGINT,
    F_STATE BIGINT,
    F_DOC_SUM NUMERIC(15,3),
    F_PRICE BIGINT,
    F_TYPE BIGINT,
    F_DOC_COUNT NUMERIC(15,3))
AS
BEGIN
  INSERT INTO T_DOC_MOVE (
    F_ID,
    F_DATE,
    F_NUMBER,
    F_SKLAD_FROM,
    F_SKLAD_TO,
    F_STATE,
    F_DOC_SUM,
    F_PRICE,
    F_TYPE,
    F_DOC_COUNT)
  VALUES (
    :F_ID,
    :F_DATE,
    :F_NUMBER,
    :F_SKLAD_FROM,
    :F_SKLAD_TO,
    :F_STATE,
    :F_DOC_SUM,
    :F_PRICE,
    :F_TYPE,
    :F_DOC_COUNT);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_S
RETURNS (
    F_ID BIGINT,
    F_DATE DATE,
    F_NUMBER VARCHAR(20),
    F_SKLAD_FROM BIGINT,
    F_SKLAD_TO BIGINT,
    F_STATE BIGINT,
    F_STATE_NAME VARCHAR(100),
    F_DOC_SUM NUMERIC(15,3),
    F_PRICE BIGINT,
    F_TYPE BIGINT,
    F_TYPE_NAME VARCHAR(60),
    F_DOC_COUNT NUMERIC(15,3),
    F_SKLAD_FROM_NAME VARCHAR(60),
    F_SKLAD_TO_NAME VARCHAR(60))
AS
BEGIN
  FOR SELECT F_ID,
             F_DATE,
             F_NUMBER,
             F_SKLAD_FROM,
             F_SKLAD_TO,
             F_STATE,
             F_DOC_SUM,
             F_PRICE,
             F_TYPE,
             F_DOC_COUNT
      FROM T_DOC_MOVE
      INTO :F_ID,
           :F_DATE,
           :F_NUMBER,
           :F_SKLAD_FROM,
           :F_SKLAD_TO,
           :F_STATE,
           :F_DOC_SUM,
           :F_PRICE,
           :F_TYPE,
           :F_DOC_COUNT
  DO
  BEGIN
    if (coalesce(f_sklad_from,-1)>0) then
      select f_name from sp_t_nsi_sklad_get(:f_sklad_from) into :f_sklad_from_name;
    else
      f_sklad_from_name=null;
    if (coalesce(f_sklad_to,-1)>0) then
      select f_name from sp_t_nsi_sklad_get(:f_sklad_to) into :f_sklad_to_name;
    else
      f_sklad_to_name=null;
    if (f_state is null) then
      f_state_name=null;
    else
    begin
      select f_name from SP_T_NSI_STATE_GET(:f_state) into :f_state_name;
    end
    if (f_type is null) then
      f_type_name=null;
    else
      select f_name from SP_T_NSI_DOC_MOVE_TYPES_get(:f_type) into :f_type_name;
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_STR_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_DOC_MOVE_STR
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_STR_I (
    F_ID BIGINT,
    F_DOC_MOVE BIGINT,
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_CNT NUMERIC(15,3),
    F_PRICE_VAL NUMERIC(15,3))
AS
DECLARE VARIABLE V_PRICE_ID BIGINT;
BEGIN
  if (exists(select 1 from t_doc_move where f_id=:f_doc_move)) then
  begin
    select f_price from sp_t_doc_move_get(:f_doc_move) into :v_price_id;
    if (F_PRICE_val is null) then
      select f_value from SP_T_PRICE_GET(:v_price_id,:f_good) into :F_PRICE_val;
  end
  if (exists(select 1 from T_DOC_move_STR where
      f_doc_move=:F_DOC_move and F_GOOD=:F_GOOD)) then
  begin
    update T_DOC_move_STR
    set F_CNT=F_CNT+coalesce(:F_CNT,1)
    where f_doc_move=:F_DOC_move and F_GOOD=:F_GOOD;
  end
  else
    INSERT INTO T_DOC_MOVE_STR (
      F_ID,
      F_DOC_MOVE,
      F_GOOD,
      F_PRICE,
      F_CNT,
      F_PRICE_VAL)
    VALUES (
      :F_ID,
      :F_DOC_MOVE,
      :F_GOOD,
      :F_PRICE,
      coalesce(:F_CNT,1),
      :F_PRICE_VAL);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_STR_S (
    F_DOC_MOVE_IN BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC_MOVE BIGINT,
    F_GOOD_NAME VARCHAR(255),
    F_GOOD_DOP_INFO VARCHAR(10000),
    F_SCANCODE VARCHAR(20),
    F_ED_IZM_SHORT_NAME VARCHAR(60),
    F_ED_IZM_NAME VARCHAR(60),
    F_ARTICLE VARCHAR(20),
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_CNT NUMERIC(15,3),
    F_PRICE_VAL NUMERIC(15,3),
    F_SUM NUMERIC(18,6),
    F_GOOD_PARTNER BIGINT)
AS
BEGIN
  FOR SELECT F_ID,
             F_DOC_MOVE,
             F_GOOD,
             F_PRICE,
             F_CNT,
             F_PRICE_VAL,
             F_SUM
      FROM T_DOC_MOVE_STR
      where
        f_doc_move=:f_doc_move_in
      INTO :F_ID,
           :F_DOC_MOVE,
           :F_GOOD,
           :F_PRICE,
           :F_CNT,
           :F_PRICE_VAL,
           :F_SUM
  DO
  BEGIN
    if (f_good is not null) then
    begin
      select f_name,f_article,f_ed_izm_name,f_ed_izm_short_name,f_scancode,f_dop_info,f_partner from sp_t_nsi_goods_get(:f_good,null)
        into :f_good_name,:f_article,:f_ed_izm_name,:f_ed_izm_short_name,:f_scancode,:f_good_dop_info,:f_good_partner;
    end
    else
      f_good_name=null;
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_STR_S_BY_CNT (
    MOVE_DOC BIGINT,
    CNT BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC_MOVE BIGINT,
    F_GOOD BIGINT,
    F_PRICE_VAL FLOAT,
    F_CNT FLOAT,
    F_SUM FLOAT,
    F_GOOD_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_SCANCODE VARCHAR(60),
    F_GOOD_DOP_INFO VARCHAR(255))
AS
DECLARE VARIABLE DOC_CNT INTEGER;
BEGIN
  FOR SELECT F_ID,
             F_DOC_move,
             F_GOOD,
             F_PRICE_val,
             F_CNT,
             F_SUM
      FROM T_DOC_Move_STR
      where
        f_doc_move=:move_doc
      INTO :F_ID,
           :F_DOC_move,
           :F_GOOD,
           :F_PRICE_val,
           :F_CNT,
           :F_SUM
  DO
  BEGIN
    doc_cnt=0;
    if (coalesce(f_good,-1)>0) then
      select f_name,f_article,f_ed_izm_name,f_ed_izm_short_name,f_scancode,f_dop_info from sp_t_nsi_goods_get(:f_good,null)
        into :f_good_name,:f_article,:f_ed_izm_name,:f_ed_izm_short_name,:f_scancode,:f_good_dop_info;
    doc_cnt=coalesce(cnt,F_CNT);
    while (doc_cnt>0) do
    begin
      SUSPEND;
      doc_cnt=doc_cnt-1;
    end
  END
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_STR_U (
    F_ID BIGINT,
    F_DOC_MOVE BIGINT,
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_CNT NUMERIC(15,3),
    F_PRICE_VAL NUMERIC(15,3))
AS
BEGIN
  UPDATE T_DOC_MOVE_STR
  SET F_DOC_MOVE = :F_DOC_MOVE,
      F_GOOD = :F_GOOD,
      F_PRICE = :F_PRICE,
      F_CNT = :F_CNT,
      F_PRICE_VAL = :F_PRICE_VAL
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_MOVE_U (
    F_ID BIGINT,
    F_DATE DATE,
    F_NUMBER VARCHAR(20),
    F_SKLAD_FROM BIGINT,
    F_SKLAD_TO BIGINT,
    F_STATE BIGINT,
    F_DOC_SUM NUMERIC(15,3),
    F_PRICE BIGINT,
    F_TYPE BIGINT,
    F_DOC_COUNT NUMERIC(15,3))
AS
BEGIN
  if (f_sklad_to is not null) then
    UPDATE T_DOC_MOVE  l
    SET
      F_SKLAD_TO = :F_SKLAD_TO
    WHERE (F_ID = :F_ID and coalesce(F_SKLAD_TO,-1)<>:f_sklad_to);
  if (f_sklad_from is not null) then
    UPDATE T_DOC_MOVE
    SET
      F_SKLAD_from = :F_SKLAD_from
    WHERE (F_ID = :F_ID and coalesce(F_SKLAD_from,-1) <>:f_sklad_from);
  update
    T_DOC_MOVE
  set f_price=:f_price
  where f_price<>coalesce(:f_price,f_price)
    and f_id=:f_id;
  update
    T_DOC_MOVE
  set F_STATE=:F_STATE
  where F_STATE<>coalesce(:F_STATE,F_STATE)
    and f_id=:f_id;

  UPDATE T_DOC_MOVE
  SET F_DATE = :F_DATE
--      F_NUMBER = :F_NUMBER
--      F_STATE = :F_STATE,
--      F_DOC_SUM = :F_DOC_SUM,
--      F_PRICE = :F_PRICE
--      F_TYPE = :F_TYPE
--      F_DOC_COUNT = :F_DOC_COUNT
  WHERE (F_ID = :F_ID) and f_date<>coalesce(:f_date,f_date);

  UPDATE T_DOC_MOVE
  SET --F_DATE = :F_DATE,
      F_NUMBER = :F_NUMBER
--      F_STATE = :F_STATE,
--      F_DOC_SUM = :F_DOC_SUM,
--      F_PRICE = :F_PRICE
--      F_TYPE = :F_TYPE
--      F_DOC_COUNT = :F_DOC_COUNT
  WHERE (F_ID = :F_ID) and f_number<>coalesce(:f_number,f_number);

  update
    T_DOC_MOVE
  set F_STATE=:F_STATE
  where F_STATE<>coalesce(:F_STATE,F_STATE)
    and f_id=:f_id;

END^


CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_DOC_OUT
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_GET (
    DOC_ID BIGINT,
    DOC_TYPE BIGINT = 1,
    DOC_SKLAD BIGINT = null)
RETURNS (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(60),
    F_DATE DATE,
    F_PAYDATE_PLAN DATE,
    F_DOC_SUM NUMERIC(15,3),
    F_STATE BIGINT,
    F_PRICE BIGINT,
    F_PRICE_NAME VARCHAR(60),
    F_STATE_NAME VARCHAR(60),
    F_PARTNER_NAME VARCHAR(60),
    F_PARTNER_ADRES VARCHAR(255),
    F_PARTNER_INN VARCHAR(20),
    F_PARTNER_KPP VARCHAR(20),
    F_PARTNER_BANK VARCHAR(60),
    F_PARTNER_BANK_ADRES VARCHAR(255),
    F_PARTNER_BANK_RSCH VARCHAR(20),
    F_PARTNER_BANK_KSCH VARCHAR(20),
    F_PARTNER_BANK_BIK VARCHAR(20),
    F_SKLAD_NAME VARCHAR(60),
    F_SKLAD_ADRES VARCHAR(255),
    F_SKLAD_F_NAME VARCHAR(60),
    F_SKLAD_U_ADRES VARCHAR(255),
    F_SKLAD_INN VARCHAR(20),
    F_SKLAD_KPP VARCHAR(20),
    F_SKLAD_BANK VARCHAR(255),
    F_SKLAD_BANK_ADRES VARCHAR(255),
    F_SKLAD_BANK_RSCH VARCHAR(20),
    F_SKLAD_BANK_KSCH VARCHAR(20),
    F_SKLAD_BANK_BIK VARCHAR(20),
    F_SKIDKA INTEGER,
    F_PAY_SUM NUMERIC(15,3),
    F_TYPE BIGINT,
    F_TYPE_NAME VARCHAR(60))
AS
declare variable V_PAYCHECK_DAY bigint;
begin
  if (not exists (select f_id from t_doc_out where f_id=:doc_id)) then
  begin
    f_id=GEN_ID(GEN_t_doc_out_ID,1);
    if (not exists(select f_id from t_nsi_sklad where f_id=:doc_sklad)) then
      select param_value from SP_GET_SYS_PARAM('default_sklad') into :f_sklad;
    else
      f_sklad=:doc_sklad;
    f_date='now';
    select param_value from SP_GET_SYS_PARAM('out_doc_state') into :f_state;

    select param_value from SP_GET_SYS_PARAM('default_out_price') into :f_price;

    select f_name,coalesce(f_price_out,:f_price) from sp_t_nsi_sklad_get(:f_sklad) into :f_sklad_name,:f_price;
    select f_name from sp_t_nsi_price_get(:f_price) into :f_price_name;
    f_number=f_id;
    if (doc_type=2) then
        select f_partner_rozn from t_nsi_sklad where f_id=:f_sklad into :f_partner;
    select param_value from  SP_GET_SYS_PARAM('PAY_CHECK_DAY') into :v_paycheck_day;
    f_paydate_plan=f_date+coalesce(v_paycheck_day,0);
    execute procedure sp_t_doc_out_i(:f_id,:f_sklad,:f_partner,:f_number,:f_date,:f_state,:f_price,:f_paydate_plan,:doc_type);
  end
  else
  begin
    select
        f_id, 
        f_sklad,
        f_partner, 
        f_number, 
        f_date, 
        f_state,
        f_price,
        f_doc_sum,
        f_skidka,
--        0,
        f_pay_sum,
        f_paydate_plan,
        f_type
    from
        t_doc_out
    where
        f_id=:doc_id
    into
        :f_id,
        :f_sklad,
        :f_partner,
        :f_number,
        :f_date,
        :f_state,
        :f_price,
        :f_doc_sum,
        :f_skidka,
        :f_pay_sum,
        :f_paydate_plan,
        :f_type;
    if (coalesce(f_partner,-1)>0) then
      select
        f_name,
        f_inn,
        f_kpp,
        f_u_addres,
        f_bank,
        f_bank_adres,
        f_bank_rsch,
        f_bank_ksch,
        f_bank_bik
      from sp_t_nsi_partner_get(:f_partner)
      into
        :f_partner_name,
        :f_partner_inn,
        :f_partner_kpp,
        :f_partner_adres,
        :f_partner_bank,
        :f_partner_bank_adres,
        :f_partner_bank_rsch,
        :f_partner_bank_ksch,
        :f_partner_bank_bik;
    if (coalesce(f_sklad,-1)>0) then
      select
        f_name,
        f_addres,
        f_partner_name,
        f_partner_adres,
        f_partner_inn,
        f_partner_kpp,
        f_partner_bank, 
        f_partner_bank_adres,
        f_partner_bank_ksch, 
        f_partner_bank_rsch, 
        f_partner_bank_bik
      from sp_t_nsi_sklad_get(:f_sklad)
      into
        :f_sklad_name,
        :f_sklad_adres,
        :f_sklad_f_name,
        :f_sklad_u_adres,
        :f_sklad_inn,
        :f_sklad_kpp,
        :f_sklad_bank,
        :f_sklad_bank_adres,
        :f_sklad_bank_ksch,
        :f_sklad_bank_rsch,
        :f_sklad_bank_bik;
    if (coalesce(f_price,-1)>0) then
      select f_name from sp_t_nsi_price_get(:f_price) into :f_price_name;
  end
  select f_name from SP_T_NSI_STATE_get(:f_state) into :f_state_name;
  select f_name from sp_t_nsi_doc_out_types_get(:f_type) into :f_type_name;
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_I (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_STATE BIGINT,
    F_PRICE BIGINT,
    F_PAYDATE_PLAN DATE,
    F_DOC_TYPE BIGINT = 1)
AS
BEGIN
  INSERT INTO T_DOC_OUT (
    F_ID,
    F_SKlAD,
    F_PARTNER,
    F_NUMBER,
    F_DATE,
    F_STATE,
    f_price,
    f_paydate_plan,
    f_type)
  VALUES (
    :F_ID,
    :F_SKlAD,
    :F_PARTNER,
    :F_NUMBER,
    :F_DATE,
    :F_STATE,
    :F_PRICE,
    :f_paydate_plan,
    :f_doc_type);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_MAKE_PAY (
    F_DOC_ID BIGINT,
    F_MONEY_TYPE BIGINT = 1,
    F_SUM INTEGER = -1)
RETURNS (
    F_MONEY_IN_ID BIGINT)
AS
DECLARE VARIABLE V_SKLAD BIGINT;
DECLARE VARIABLE V_PARTNER BIGINT;
DECLARE VARIABLE V_DATE DATE;
DECLARE VARIABLE V_NUMBER VARCHAR(20) CHARACTER SET WIN1251;
DECLARE VARIABLE V_SUMMA NUMERIC(15,3);
DECLARE VARIABLE V_STATE BIGINT;
begin
  v_date='now';
  select f_partner,f_sklad,f_number,
    case 
      when :f_sum>0 then :f_sum
      else f_doc_sum
    end
  from sp_t_doc_out_get(:f_doc_id) into :v_partner,:v_sklad,:v_number,:v_summa;
  f_money_in_id=GEN_ID(GEN_t_money_in_ID,1);
  select param_value from SP_GET_SYS_PARAM('in_pay_state') into :v_state;
  execute procedure SP_T_MONEY_IN_I(:f_money_in_id,:v_sklad,v_partner,null,:v_number,'now',:v_state,:v_summa,:f_money_type);
  execute procedure sp_t_money_in_str_i(null,:f_doc_id,:f_money_in_id,:v_summa);
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_S (
    DOC_TYPE INTEGER = -1)
RETURNS (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_PAYDATE_PLAN DATE,
    F_STATE BIGINT,
    F_DOC_COUNT FLOAT,
    F_DOC_SUM NUMERIC(15,3),
    F_STATE_NAME VARCHAR(60),
    F_SKLAD_NAME VARCHAR(60),
    F_PARTNER_NAME VARCHAR(60),
    F_DOC_SKIDKA NUMERIC(15,3),
    F_DOC_SKIDKA_PERCENT NUMERIC(15,3),
    F_PRICE_NAME VARCHAR(60),
    F_PRICE BIGINT)
AS
BEGIN
  FOR SELECT F_ID,
             F_SKlAD,
             F_PARTNER,
             F_NUMBER,
             F_DATE,
             f_paydate_plan,
             F_STATE,
             f_doc_count,
             f_doc_sum,
             f_skidka,
             f_price
      FROM T_DOC_OUT
      where
        f_type=:doc_type or
        coalesce(:doc_type,-1)<0
      INTO :F_ID,
           :F_SKlAD,
           :F_PARTNER,
           :F_NUMBER,
           :F_DATE,
           :f_paydate_plan,
           :F_STATE,
           :f_doc_count,
           :f_doc_sum,
           :f_doc_skidka_percent,
           :f_price
  DO
  BEGIN
    if (f_sklad is not null) then
      select F_name from sp_t_nsi_sklad_get(:f_sklad) into :f_sklad_name;
    else
      f_sklad_name=null;
    if (f_state is not null) then
      select F_name from sp_t_nsi_state_get(:f_state) into :f_state_name;
    else
      f_state_name=null;
    if (f_partner is not null) then
      select F_name from sp_t_nsi_partner_get(:f_partner) into :f_partner_name;
    else
      f_partner_name=null;
    if (f_price is not null) then
      select f_name from sp_t_nsi_price_get(:f_price) into :f_price_name;
    else
      f_price_name=null;
/*    if (f_doc_skidka_percent>0) then
    begin*/
      select sum((coalesce(f_price_val_nsi,f_price_val)-f_price_val)*f_cnt) from t_doc_out_str where f_doc_out=:f_id into :f_doc_skidka;
--      f_doc_skidka=f_doc_sum/(100-f_doc_skidka_percent)*f_doc_skidka_percent;
/*    end
    else
      f_doc_skidka=0;*/
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_STR_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_DOC_OUT_STR
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_STR_I (
    F_ID BIGINT,
    F_DOC_OUT BIGINT,
    F_GOOD BIGINT,
    F_PRICE NUMERIC(15,3),
    F_CNT FLOAT,
    F_SUM FLOAT,
    F_SKD NUMERIC(15,3) = 0)
AS
DECLARE VARIABLE V_PRICE_NSI_ID BIGINT;
DECLARE VARIABLE V_PRICE NUMERIC(15,3);
DECLARE VARIABLE V_PRICE_VAL BIGINT;
DECLARE VARIABLE F_SKIDKA INTEGER;
DECLARE VARIABLE V_ROUND NUMERIC(15,3);
DECLARE VARIABLE V_PRICE_VAL_SK NUMERIC(15,3);
DECLARE VARIABLE V_SKIDKA_ID BIGINT;
DECLARE VARIABLE V_SKIDKA_ROUND NUMERIC(15,3);
BEGIN
  select param_value from sp_get_sys_param('OUT_DOC_SKIDKA') into :V_SKIDKA_id;
  select f_round from t_nsi_skidka where f_id=:v_skidka_id into :v_skidka_round;


  select coalesce(f_skidka,0),coalesce(f_price,0) from sp_t_doc_out_get(:f_doc_out) into :f_skidka,:v_price;
  if (v_price>0) then
  begin
    select f_id,f_value from SP_T_PRICE_GET(:v_price,:f_good) into :v_price_nsi_id,:v_price_val;
    select f_round from sp_t_nsi_price_get(:v_price) into :v_round;
  end
  else
  begin
    v_price_val=f_price;
  end
  if (coalesce(f_skd,0)=0) then
    v_price_val_sk=v_price_val*(100-f_skidka)/100.00;
  else
  begin
    v_price_val=f_price+coalesce(:f_skd/:f_cnt,0);
    v_price_val_sk=f_price;
  end
  if (v_price_val_sk<>v_price_val) then
    select f_result from sp_round(:v_price_val_sk,:v_skidka_round) into :v_price_val_sk;
  if (exists(select 1 from T_DOC_OUT_STR where
      f_doc_out=:F_DOC_OUT and F_GOOD=:F_GOOD)) then
  begin
    update T_DOC_OUT_STR
    set F_CNT=F_CNT+coalesce(:F_CNT,1)
    where f_doc_out=:F_DOC_OUT and F_GOOD=:F_GOOD;
  end
  else
  begin
    INSERT INTO T_DOC_OUT_STR (
      F_ID,
      F_DOC_OUT,
      F_GOOD,
      F_PRICE,
      F_CNT,
      f_price_val,
      f_price_val_nsi)
    VALUES (
      :F_ID,
      :F_DOC_OUT,
      :F_GOOD,
      :v_price_nsi_id,
      coalesce(:F_CNT,1),
      :v_price_val_sk,
      :v_price_val
      );
   end
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_STR_S (
    DOC_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC_OUT BIGINT,
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_CNT FLOAT,
    F_SUM FLOAT,
    F_GOOD_NAME VARCHAR(255),
    F_PRICE_VAL FLOAT,
    F_ARTICLE VARCHAR(20),
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_SKLAD_OST FLOAT,
    F_SKIDKA NUMERIC(15,3),
    F_GOOD_PARNER BIGINT)
AS
DECLARE VARIABLE F_SKLAD BIGINT;
DECLARE VARIABLE F_DATE DATE;
DECLARE VARIABLE F_DOC_STATE BIGINT;
DECLARE VARIABLE F_SKIDKA_PERCENT INTEGER;
BEGIN
  select f_sklad, f_date, f_state, f_skidka
  from sp_t_doc_out_get(:doc_id)
  into
    :f_sklad,
    :f_date,
    :f_doc_state,
    :f_skidka_percent;
  FOR SELECT F_ID,
             F_DOC_out,
             F_GOOD,
             F_PRICE,
             F_CNT,
             F_SUM,
             F_PRICE_VAL,
             F_CNT*(coalesce(F_PRICE_VAL_NSI,F_PRICE_VAL)-F_PRICE_VAL)
--             f_sum/(100-coalesce(:f_skidka_percent,0))*coalesce(:f_skidka_percent,0)
      FROM T_DOC_out_STR
      where
        f_doc_out=:doc_id
      INTO :F_ID,
           :F_DOC_out,
           :F_GOOD,
           :F_PRICE,
           :F_CNT,
           :F_SUM,
           :F_PRICE_VAL,
           :f_skidka
  DO
  BEGIN
    if (coalesce(f_good,-1)>0) then
    begin
      select f_name,f_article,f_ed_izm_name,f_ed_izm_short_name,f_partner from sp_t_nsi_goods_get(:f_good,null)
        into :f_good_name,:f_article,:f_ed_izm_name,:f_ed_izm_short_name,:f_good_parner;
      select f_end_ost from sp_t_reg_good_get(:f_good,:f_date,:f_sklad) into :f_sklad_ost;
      if ( not exists(select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE') where param_value>=:f_doc_state)) then
        f_sklad_ost=f_sklad_ost-f_cnt;
    end
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_STR_S_BY_CNT (
    DOC_OUT BIGINT,
    CNT BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC_OUT BIGINT,
    F_GOOD BIGINT,
    F_PRICE_VAL FLOAT,
    F_CNT FLOAT,
    F_SUM FLOAT,
    F_GOOD_NAME VARCHAR(255),
    F_ARTICLE VARCHAR(20),
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_SCANCODE VARCHAR(60),
    F_GOOD_DOP_INFO VARCHAR(255))
AS
DECLARE VARIABLE DOC_CNT INTEGER;
BEGIN
  FOR SELECT F_ID,
             F_DOC_out,
             F_GOOD,
             F_PRICE_val,
             F_CNT,
             F_SUM
      FROM T_DOC_out_STR
      where
        f_doc_out=:doc_out
      INTO :F_ID,
           :F_DOC_out,
           :F_GOOD,
           :F_PRICE_val,
           :F_CNT,
           :F_SUM
  DO
  BEGIN
    doc_cnt=0;
    if (coalesce(f_good,-1)>0) then
      select f_name,f_article,f_ed_izm_name,f_ed_izm_short_name,f_scancode,f_dop_info from sp_t_nsi_goods_get(:f_good,null)
        into :f_good_name,:f_article,:f_ed_izm_name,:f_ed_izm_short_name,:f_scancode,:f_good_dop_info;
    doc_cnt=coalesce(cnt,F_CNT);
    while (doc_cnt>0) do
    begin
      SUSPEND;
      doc_cnt=doc_cnt-1;
    end
  END
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_STR_U (
    F_ID BIGINT,
    F_DOC_OUT BIGINT,
    F_GOOD BIGINT,
    F_PRICE_VAL BIGINT,
    F_CNT FLOAT,
    F_SUM FLOAT)
AS
BEGIN
  UPDATE T_DOC_OUT_STR
  SET F_DOC_OUT = coalesce(:F_DOC_OUT,f_doc_out),
      F_GOOD = coalesce(:F_GOOD,f_good),
      F_PRICE_VAL = coalesce(:F_PRICE_VAL,f_price_val),
      F_CNT = coalesce(:F_CNT,f_cnt)
--      F_SUM = :F_SUM
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_OUT_U (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_PAYDATE_PLAN DATE,
    F_STATE BIGINT,
    F_PRICE INTEGER,
    F_SKIDKA INTEGER)
AS
BEGIN
  UPDATE T_DOC_OUT
  SET F_SKlAD = coalesce(:F_SKlAD,f_sklad),
      F_PARTNER = coalesce(:F_PARTNER,f_partner),
      F_NUMBER = coalesce(:F_NUMBER,f_number),
      F_DATE = coalesce(:F_DATE,f_date),
      f_paydate_plan = coalesce(:f_paydate_plan,f_paydate_plan),
      F_STATE = coalesce(:F_STATE,F_STATE),
      F_PRICE = :f_price, --coalesce(:F_PRICE,f_price),
      f_skidka = coalesce(:f_skidka,f_skidka)
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_DOC_PRICE
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_GET (
    F_PRICE_DOC BIGINT,
    F_PARENT_PRICE_DOC BIGINT = null)
RETURNS (
    F_ID BIGINT,
    F_NUM VARCHAR(20),
    F_DATE DATE,
    F_PARENT BIGINT,
    F_STATE BIGINT,
    F_PRICE BIGINT,
    F_PRICE_NAME VARCHAR(60),
    F_STATE_NAME VARCHAR(60))
AS
BEGIN
  if (f_price_doc is null) then
  begin
    f_id=GEN_ID(GEN_t_doc_price_ID,1);
    f_date='now';
    select param_value from SP_GET_SYS_PARAM('out_doc_state') into :f_state;
    f_num=f_id;
    execute procedure sp_t_doc_price_i(:f_id,:f_num,:f_date,:f_parent_price_doc,:f_state,:f_price);
  end
  else
  begin
    SELECT F_ID,
             F_NUM,
             F_DATE,
             F_PARENT,
             F_StATE,
             F_PRICE
    FROM T_DOC_PRICE
    where
      f_id=:f_price_doc
    INTO :F_ID,
         :F_NUM,
         :F_DATE,
         :F_PARENT,
         :F_StATE,
         :F_PRICE;
    select f_name from sp_t_nsi_price_get(coalesce(:f_price,-1)) into :f_price_name;
    select f_name from sp_t_nsi_state_get(coalesce(:f_state,-1)) into :f_state_name;
  end
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_I (
    F_ID BIGINT,
    F_NUM VARCHAR(20),
    F_DATE DATE,
    F_PARENT BIGINT,
    F_SATE BIGINT,
    F_PRICE BIGINT)
AS
BEGIN
  INSERT INTO T_DOC_PRICE (
    F_ID,
    F_NUM,
    F_DATE,
    F_PARENT,
    F_STATE,
    F_PRICE)
  VALUES (
    :F_ID,
    :F_NUM,
    :F_DATE,
    :F_PARENT,
    :F_SATE,
    :F_PRICE);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_S
RETURNS (
    F_ID BIGINT,
    F_NUM VARCHAR(20),
    F_DATE DATE,
    F_PARENT BIGINT,
    F_STATE BIGINT,
    F_PRICE BIGINT,
    F_PRICE_NAME VARCHAR(60),
    F_STATE_NAME VARCHAR(60),
    F_NACENKA NUMERIC(15,3))
AS
BEGIN
  FOR SELECT F_ID,
             F_NUM,
             F_DATE,
             F_PARENT,
             F_StATE,
             F_PRICE,
             f_nacenka
      FROM T_DOC_PRICE
      INTO :F_ID,
           :F_NUM,
           :F_DATE,
           :F_PARENT,
           :F_StATE,
           :F_PRICE,
           :f_nacenka
  DO
  BEGIN
    if (f_price is not null) then
      select f_name from sp_t_nsi_price_get(:f_price) into :f_price_name;
    else
      f_price_name=null;
    if (f_state is not null) then
      select f_name from sp_t_nsi_state_get(:f_state) into :f_state_name;
    else
      f_state_name=null;
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_STR_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_DOC_PRICE_STR
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_STR_I (
    F_GOOD BIGINT,
    F_PRICE NUMERIC(15,3),
    F_DOC_PRICE BIGINT)
AS
BEGIN
  INSERT INTO T_DOC_PRICE_STR (
    F_GOOD,
    F_PRICE,
    F_DOC_PRICE)
  VALUES (
    :F_GOOD,
    :F_PRICE,
    :F_DOC_PRICE);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_STR_S (
    F_DOC_PRICE_ID INTEGER)
RETURNS (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_PRICE NUMERIC(15,3),
    F_DOC_PRICE BIGINT,
    F_GOOD_NAME VARCHAR(255),
    F_GOOD_ARTICLE VARCHAR(20),
    F_OLD_PRICE NUMERIC(15,3))
AS
BEGIN
  FOR SELECT F_ID,
             F_GOOD,
             F_PRICE,
             F_DOC_PRICE,
             f_old_price
      FROM T_DOC_PRICE_STR
      where
        f_doc_price=:f_doc_price_id
      INTO :F_ID,
           :F_GOOD,
           :F_PRICE,
           :F_DOC_PRICE,
           :f_old_price
  DO
  BEGIN
    select f_name,f_article from sp_t_nsi_goods_get(coalesce(:f_good,-1),null) into :f_good_name,:f_good_article;
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_STR_U (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_PRICE NUMERIC(15,3),
    F_DOC_PRICE BIGINT)
AS
BEGIN
  UPDATE T_DOC_PRICE_STR
  SET F_GOOD = :F_GOOD,
      F_PRICE = :F_PRICE,
      F_DOC_PRICE = :F_DOC_PRICE
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_DOC_PRICE_U (
    F_ID BIGINT,
    F_NUM VARCHAR(20),
    F_DATE DATE,
    F_PARENT BIGINT,
    F_STATE BIGINT,
    F_PRICE BIGINT)
AS
BEGIN
  UPDATE T_DOC_PRICE
  SET F_NUM = :F_NUM,
      F_DATE = :F_DATE,
      F_PARENT = :F_PARENT,
      F_STATE = :F_STATE,
      F_PRICE = :F_PRICE
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_INVENTORY
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_INVENTORY_DOC
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_GET (
    F_INVENTORY_DOC BIGINT,
    F_INV BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_MANAGER VARCHAR(100),
    F_DOC_COUNT NUMERIC(15,3),
    F_INVENTORY BIGINT,
    F_STATE BIGINT,
    F_STATE_NAME VARCHAR(60))
AS
BEGIN
  if (coalesce(f_inventory_doc,-1) < 1 ) then
  begin
    f_id=GEN_ID(GEN_t_inventory_doc_ID,1);
    f_number=f_id;
    select param_value from SP_GET_SYS_PARAM('inventory_doc_state') into :f_state;
    execute procedure sp_t_inventory_doc_i(:f_id,:f_number, :f_manager,null,:f_inv,:f_state);
  end

  SELECT F_ID,
             F_NUMBER,
             F_MANAGER,
             F_DOC_COUNT,
             F_INVENTORY,
             F_STATE
      FROM T_INVENTORY_DOC
      where
        f_id=:f_inventory_doc
      INTO :F_ID,
           :F_NUMBER,
           :F_MANAGER,
           :F_DOC_COUNT,
           :F_INVENTORY,
           :F_STATE;
    if (f_state is not null) then
    begin
      select f_name from t_nsi_state where f_id=:f_state into :f_state_name;
    end
    SUSPEND;
    f_state=null;
END^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_I (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_MANAGER VARCHAR(100),
    F_DOC_COUNT NUMERIC(15,3),
    F_INVENTORY BIGINT,
    F_STATE BIGINT)
AS
BEGIN
  INSERT INTO T_INVENTORY_DOC (
    F_ID,
    F_NUMBER,
    F_MANAGER,
    F_DOC_COUNT,
    F_INVENTORY,
    F_STATE)
  VALUES (
    :F_ID,
    :F_NUMBER,
    :F_MANAGER,
    :F_DOC_COUNT,
    :F_INVENTORY,
    :F_STATE);
END^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_S (
    F_INV BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_MANAGER VARCHAR(100),
    F_DOC_COUNT NUMERIC(15,3),
    F_INVENTORY BIGINT,
    F_STATE BIGINT,
    F_STATE_NAME VARCHAR(60))
AS
BEGIN
  FOR SELECT F_ID,
             F_NUMBER,
             F_MANAGER,
             F_DOC_COUNT,
             F_INVENTORY,
             F_STATE
      FROM T_INVENTORY_DOC
      where
        f_inventory=:f_inv
      INTO :F_ID,
           :F_NUMBER,
           :F_MANAGER,
           :F_DOC_COUNT,
           :F_INVENTORY,
           :F_STATE
  DO
  BEGIN
    if (f_state is not null) then
    begin
      select f_name from t_nsi_state where f_id=:f_state into :f_state_name;
    end
    SUSPEND;
    f_state=null;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_STR_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_INVENTORY_DOC_STR
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_STR_I (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_COUNT NUMERIC(15,3),
    F_INVENTORY_DOC BIGINT)
AS
BEGIN
  if (exists (select f_id from t_inventory_doc_str where f_good=:f_good and f_inventory_doc=:f_inventory_doc)) then
  begin
    update t_inventory_doc_str set f_count=coalesce(f_count,0)+coalesce(:f_count,1)
      where f_good=:f_good and f_inventory_doc=:f_inventory_doc;
  end
  else
  begin
    INSERT INTO T_INVENTORY_DOC_STR (
        F_ID,
        F_GOOD,
        F_COUNT,
        F_INVENTORY_DOC)
    VALUES (
        :F_ID,
        :F_GOOD,
        coalesce(:F_COUNT,1),
        :F_INVENTORY_DOC);
  end
END^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_STR_S (
    F_INV_DOC BIGINT)
RETURNS (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_GOOD_ARTICLE VARCHAR(20),
    F_GOOD_NAME VARCHAR(255),
    F_COUNT NUMERIC(15,3),
    F_INVENTORY_DOC BIGINT)
AS
BEGIN
  FOR SELECT s.F_ID,
             s.F_GOOD,
             g.f_article,
             g.f_name,
             s.F_COUNT,
             s.F_INVENTORY_DOC
      FROM
        T_INVENTORY_DOC_STR s
        inner join t_nsi_goods g on s.f_good=g.f_id
      where
        f_inventory_doc=:f_inv_doc
      INTO :F_ID,
           :F_GOOD,
           :f_good_article,
           :f_good_name,
           :F_COUNT,
           :F_INVENTORY_DOC
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_STR_U (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_COUNT NUMERIC(15,3),
    F_INVENTORY_DOC BIGINT)
AS
BEGIN
  UPDATE T_INVENTORY_DOC_STR
  SET F_GOOD = :F_GOOD,
      F_COUNT = :F_COUNT,
      F_INVENTORY_DOC = :F_INVENTORY_DOC
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_DOC_U (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_MANAGER VARCHAR(100),
    F_DOC_COUNT NUMERIC(15,3),
    F_INVENTORY BIGINT,
    F_STATE BIGINT)
AS
BEGIN
  UPDATE T_INVENTORY_DOC
  SET F_NUMBER = :F_NUMBER,
      F_MANAGER = :F_MANAGER,
      F_STATE = :F_STATE
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_GET (
    F_INVENTORY BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE_START DATE,
    F_DATE_COMPLETE DATE,
    F_SKLAD_NAME VARCHAR(60),
    F_SKLAD BIGINT,
    F_STATE BIGINT)
AS
BEGIN
  if (coalesce(f_inventory,-1) < 1 ) then
  begin
    f_id=GEN_ID(GEN_t_inventory_ID,1);
    f_number=f_id;
    select param_value from SP_GET_SYS_PARAM('default_sklad') into :f_sklad;
    execute procedure sp_t_inventory_i(:f_id,:f_number, :f_date_start,null,:f_sklad,:f_state);
  end

  SELECT F_ID,
             F_NUMBER,
             F_DATE_START,
             F_DATE_COMPLETE,
             F_SKLAD,
             F_STATE
      FROM T_INVENTORY
      where
        f_id=:f_inventory
      INTO :F_ID,
           :F_NUMBER,
           :F_DATE_START,
           :F_DATE_COMPLETE,
           :F_SKLAD,
           :F_STATE;
    if (f_sklad is not null) then
    begin
      select f_name from sp_t_nsi_sklad_get(:f_sklad) into :f_sklad_name;
    end
    SUSPEND;
    f_sklad=null;
end^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_I (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE_START DATE,
    F_DATE_COMPLETE DATE,
    F_SKLAD BIGINT,
    F_STATE BIGINT)
AS
BEGIN
  INSERT INTO T_INVENTORY (
    F_ID,
    F_NUMBER,
    F_DATE_START,
    F_DATE_COMPLETE,
    F_SKLAD,
    F_STATE)
  VALUES (
    :F_ID,
    :F_NUMBER,
    :F_DATE_START,
    :F_DATE_COMPLETE,
    :F_SKLAD,
    :F_STATE);
END^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_S
RETURNS (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE_START DATE,
    F_DATE_COMPLETE DATE,
    F_SKLAD_NAME VARCHAR(60),
    F_SKLAD BIGINT,
    F_STATE BIGINT)
AS
BEGIN
  FOR SELECT F_ID,
             F_NUMBER,
             F_DATE_START,
             F_DATE_COMPLETE,
             F_SKLAD,
             F_STATE
      FROM T_INVENTORY
      INTO :F_ID,
           :F_NUMBER,
           :F_DATE_START,
           :F_DATE_COMPLETE,
           :F_SKLAD,
           :F_STATE
  DO
  BEGIN
    if (f_sklad is not null) then
    begin
      select f_name from sp_t_nsi_sklad_get(:f_sklad) into :f_sklad_name;
    end
    SUSPEND;
    f_sklad_name=null;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_STR_S (
    F_INV BIGINT)
RETURNS (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_GOOD_ARTICLE VARCHAR(20),
    F_GOOD_NAME VARCHAR(255),
    F_COUNT_PLAN NUMERIC(15,3),
    F_COUNT_FACT NUMERIC(15,3),
    F_INVENTORY BIGINT)
AS
BEGIN
  FOR SELECT b.F_ID,
             b.F_GOOD,
             g.f_article,
             g.f_name,
             b.F_COUNT_PLAN,
             b.F_COUNT_FACT,
             b.F_INVENTORY
      FROM T_INVENTORY_STR b
        inner join t_nsi_goods g on b.F_good=g.f_id
      where
        b.f_inventory=:f_inv
      INTO :F_ID,
           :F_GOOD,
           :f_good_article,
           :f_good_name,
           :F_COUNT_PLAN,
           :F_COUNT_FACT,
           :F_INVENTORY
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_INVENTORY_U (
    F_ID BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE_START DATE,
    F_DATE_COMPLETE DATE,
    F_SKLAD BIGINT,
    F_STATE BIGINT)
AS
BEGIN
  UPDATE T_INVENTORY
  SET F_NUMBER = :F_NUMBER,
      F_DATE_START = :F_DATE_START,
      F_DATE_COMPLETE = :F_DATE_COMPLETE,
      F_SKLAD = :F_SKLAD,
      F_STATE = :F_STATE
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_MONEY_IN
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_GET (
    F_MONEY_IN BIGINT,
    F_MONEY_TYPE BIGINT)
RETURNS (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_PARTNER_NAME VARCHAR(100),
    F_BANK BIGINT,
    F_BANK_NAME VARCHAR(100),
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_STATE_NAME VARCHAR(100),
    F_STATE BIGINT,
    F_SUMMA FLOAT,
    F_TYPE_NAME VARCHAR(100),
    F_TYPE BIGINT,
    F_DOC_SUM NUMERIC(15,3))
AS
BEGIN
  f_id=f_money_in;
  if (coalesce(f_id,-1) < 1) then
  begin
    f_id=GEN_ID(GEN_t_money_in_ID,1);
    select param_value from SP_GET_SYS_PARAM('in_pay_state') into :f_state;
    select param_value from SP_GET_SYS_PARAM('default_sklad') into :f_sklad;
    f_date='now';
    f_number=f_id;
    execute procedure SP_T_MONEY_IN_I(:f_id,:f_sklad,null,null,:f_number,:f_date,:f_state,0,:f_money_type);
  end
    FOR SELECT F_ID,
             F_SKLAD,
             F_PARTNER,
             F_BANK,
             f_number, 
             F_DATE,
             F_STATE,
             F_SUMMA,
             F_TYPE,
             f_doc_sum
      FROM T_MONEY_IN
      where
        f_id=:f_id
      INTO :F_ID,
           :F_SKLAD,
           :F_PARTNER,
           :F_BANK,
           :f_number,
           :F_DATE,
           :F_STATE,
           :F_SUMMA,
           :F_TYPE,
           :f_doc_sum
    DO
    BEGIN
      if (f_partner is null) then
        f_partner_name=null;
      else
      begin
        select f_name from sp_t_nsi_partner_get(:f_partner) into :f_partner_name;
      end
      if (f_bank is null) then
        f_bank_name=null;
      else
      begin
        select f_name from sp_t_nsi_bank_get(:f_bank) into :f_bank_name;
      end
      if (f_type is null) then
        f_type_name=null;
      else
      begin
        select f_name from sp_t_nsi_money_in_types_get(:f_type) into :f_type_name;
      end
      if (f_state is null) then
        f_state_name=null;
      else
      begin
        select f_name from SP_T_NSI_STATE_GET(:f_state) into :f_state_name;
      end
      SUSPEND;
    END
END^


CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_I (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_BANK BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_STATE BIGINT,
    F_SUMMA FLOAT,
    F_TYPE BIGINT)
AS
BEGIN
  INSERT INTO T_MONEY_IN (
    F_ID,
    F_SKLAD,
    F_PARTNER,
    F_BANK,
    f_number, 
    F_DATE,
    F_STATE,
    F_SUMMA,
    F_TYPE)
  VALUES (
    :F_ID,
    :F_SKLAD,
    :F_PARTNER,
    :F_BANK,
    :f_number, 
    :F_DATE,
    :F_STATE,
    :F_SUMMA,
    :F_TYPE);
END^


CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_S
RETURNS (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_PARTNER_NAME VARCHAR(100),
    F_BANK BIGINT,
    F_BANK_NAME VARCHAR(100),
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_STATE_NAME VARCHAR(100),
    F_STATE BIGINT,
    F_SUMMA FLOAT,
    F_TYPE_NAME VARCHAR(100),
    F_TYPE BIGINT)
AS
BEGIN
  FOR SELECT F_ID,
             F_SKLAD,
             F_PARTNER,
             F_BANK,
             f_number, 
             F_DATE,
             F_STATE,
             F_SUMMA,
             F_TYPE
      FROM T_MONEY_IN
      order by f_date
      INTO :F_ID,
           :F_SKLAD,
           :F_PARTNER,
           :F_BANK,
           :f_number,
           :F_DATE,
           :F_STATE,
           :F_SUMMA,
           :F_TYPE
  DO
  BEGIN
    if (f_partner is null) then
      f_partner_name=null;
    else
    begin
      select f_name from sp_t_nsi_partner_get(:f_partner) into :f_partner_name;
    end
    if (f_bank is null) then
      f_bank_name=null;
    else
    begin
      select f_name from sp_t_nsi_bank_get(:f_bank) into :f_bank_name;
    end
    if (f_type is null) then
      f_type_name=null;
    else
    begin
      select f_name from sp_t_nsi_money_in_types_get(:f_type) into :f_type_name;
    end
    if (f_state is null) then
      f_state_name=null;
    else
    begin
      select f_name from SP_T_NSI_STATE_GET(:f_state) into :f_state_name;
    end
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_STR_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_MONEY_IN_STR
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_STR_I (
    F_ID BIGINT,
    F_DOC BIGINT,
    F_MONEY BIGINT,
    F_SUMMA FLOAT)
AS
BEGIN
  INSERT INTO T_MONEY_IN_STR (
    F_ID,
    F_DOC,
    F_MONEY,
    F_SUMMA)
  VALUES (
    :F_ID,
    :F_DOC,
    :F_MONEY,
    :F_SUMMA);
END^


CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_STR_S (
    F_MONEY_IN BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC BIGINT,
    F_MONEY BIGINT,
    F_SUMMA FLOAT,
    F_DOC_INFO VARCHAR(255))
AS
BEGIN
  FOR SELECT F_ID,
             F_DOC,
             F_MONEY,
             F_SUMMA
      FROM T_MONEY_IN_STR
      where
        f_money=:f_money_in
      INTO :F_ID,
           :F_DOC,
           :F_MONEY,
           :F_SUMMA
  DO
  BEGIN
    if (coalesce(f_doc,-1)<1) then
    begin
      f_doc_info=null;
    end
    else
    begin
      select 'Расходный документ №'||f_number||' от '||(select f_value from PR_DATE_TO_STR(f_date))||'; сумма '||
        f_doc_sum||'; Партнер "'||f_partner_name||'"'
      from SP_T_DOC_OUT_GET(:f_doc) into :f_doc_info;
    end
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_STR_S_DOC (
    F_DOC_OUT BIGINT)
RETURNS (
    F_ID BIGINT,
    F_DOC BIGINT,
    F_MONEY BIGINT,
    F_SUMMA FLOAT,
    F_DOC_INFO VARCHAR(255))
AS
BEGIN
  FOR SELECT F_ID,
             F_DOC,
             F_MONEY,
             F_SUMMA
      FROM T_MONEY_IN_STR
      where
        f_doc=:f_doc_out
      INTO :F_ID,
           :F_DOC,
           :F_MONEY,
           :F_SUMMA
  DO
  BEGIN
    if (coalesce(f_money,-1)<1) then
    begin
      f_doc_info=null;
    end
    else
    begin
      select 'Платежный документ №'||f_number||' от '||(select f_value from PR_DATE_TO_STR(f_date))||'; сумма '||
        f_summa||'; Партнер "'||f_partner_name||'"'
      from SP_T_MONEY_IN_GET(:f_money,null) into :f_doc_info;
    end
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_STR_U (
    F_ID BIGINT,
    F_DOC BIGINT,
    F_MONEY BIGINT,
    F_SUMMA FLOAT)
AS
BEGIN
  UPDATE T_MONEY_IN_STR
  SET F_DOC = :F_DOC,
      F_MONEY = :F_MONEY,
      F_SUMMA = :F_SUMMA
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_MONEY_IN_U (
    F_ID BIGINT,
    F_SKLAD BIGINT,
    F_PARTNER BIGINT,
    F_BANK BIGINT,
    F_NUMBER VARCHAR(20),
    F_DATE DATE,
    F_STATE BIGINT,
    F_SUMMA FLOAT,
    F_TYPE BIGINT)
AS
BEGIN
  UPDATE T_MONEY_IN
  SET F_SKLAD = :F_SKLAD,
      F_PARTNER = :F_PARTNER,
      F_BANK = :F_BANK,
      F_NUMBER = :F_NUMBER,
      F_DATE = :F_DATE,
      F_STATE = :F_STATE,
      F_SUMMA = :F_SUMMA,
      F_TYPE = :F_TYPE
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_BANK_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_NSI_BANK
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_BANK_GET (
    F_BANK_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20),
    F_K_SCH VARCHAR(60),
    F_BIK VARCHAR(20),
    F_XML VARCHAR(10000))
AS
BEGIN
  if (coalesce(f_bank_id, -1)<0) then
  begin
    f_id=GEN_ID(GEN_t_nsi_bank_ID,1);
    execute procedure SP_T_NSI_BANK_i(:f_id,null, null, null, null, null, null, null);
  end
  else
  begin
    f_id=f_bank_id;
  end
  SELECT F_NAME,
    F_U_NAME,
    F_U_ADDRES,
    F_INN,
    F_KPP,
    F_K_SCH,
    f_bik
  FROM T_NSI_BANK
  where
    f_id=:f_id
  INTO :F_NAME,
    :F_U_NAME,
    :F_U_ADDRES,
    :F_INN,
    :F_KPP,
    :F_K_SCH,
    :F_BIK;
  f_xml='<T_NSI_BANK>'||
    '<f_id>'||f_id||'</f_id>'||
    '<f_name><![CDATA['||f_name||']]></f_name>'||
    '<f_u_name><![CDATA['||f_u_name||']]></f_u_name>'||
    '<f_u_addres><![CDATA['||coalesce(f_u_addres,'')||']]></f_u_addres>'||
    '<f_inn>'||coalesce(f_inn,'')||'</f_inn>'||
    '<f_kpp>'||coalesce(f_kpp, '')||'</f_kpp>'||
    '<f_k_sch>'||coalesce(f_k_sch,'')||'</f_k_sch>'||
    '<f_bik>'||coalesce(f_bik,'')||'</f_bik>'||
    '</T_NSI_BANK>';
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_BANK_I (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20),
    F_K_SCH VARCHAR(60),
    F_BIK VARCHAR(20))
AS
BEGIN
  INSERT INTO T_NSI_BANK (
    F_ID,
    F_NAME,
    F_U_NAME,
    F_U_ADDRES,
    F_INN,
    F_KPP,
    F_K_SCH,
    f_bik)
  VALUES (
    :F_ID,
    :F_NAME,
    :F_U_NAME,
    :F_U_ADDRES,
    :F_INN,
    :F_KPP,
    :F_K_SCH,
    :F_BIK);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_BANK_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20),
    F_K_SCH VARCHAR(60),
    F_BIK VARCHAR(20))
AS
BEGIN
    FOR SELECT F_ID,
             F_NAME,
             F_U_NAME,
             F_U_ADDRES,
             F_INN,
             F_KPP,
             F_K_SCH,
             f_bik
      FROM T_NSI_BANK
      INTO :F_ID,
           :F_NAME,
           :F_U_NAME,
           :F_U_ADDRES,
           :F_INN,
           :F_KPP,
           :F_K_SCH,
           :F_BIK
    DO
    BEGIN
      SUSPEND;
    END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_BANK_U (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20),
    F_K_SCH VARCHAR(60),
    F_BIK INTEGER)
AS
BEGIN
  UPDATE T_NSI_BANK
  SET F_NAME = :F_NAME,
      F_U_NAME = :F_U_NAME,
      F_U_ADDRES = :F_U_ADDRES,
      F_INN = :F_INN,
      F_KPP = :F_KPP,
      F_K_SCH = :F_K_SCH,
      f_bik = :f_bik
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_DOC_IN_TYPES_GET (
    F_ID BIGINT)
RETURNS (
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  FOR SELECT
             F_NAME,
             F_DESCR
      FROM T_NSI_DOC_IN_TYPES
      where
        f_id=:F_ID
      INTO
           :F_NAME,
           :F_DESCR
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_DOC_IN_TYPES_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  FOR SELECT F_ID,
             F_NAME,
             F_DESCR
      FROM T_NSI_DOC_IN_TYPES
      INTO :F_ID,
           :F_NAME,
           :F_DESCR
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_DOC_MOVE_TYPES_GET (
    F_TYPE BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  FOR SELECT F_ID,
             F_NAME,
             F_DESCR
      FROM T_NSI_DOC_MOVE_TYPES
      where
        f_id=:f_type
      INTO :F_ID,
           :F_NAME,
           :F_DESCR
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_DOC_MOVE_TYPES_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  FOR SELECT F_ID,
             F_NAME,
             F_DESCR
      FROM T_NSI_DOC_MOVE_TYPES
      INTO :F_ID,
           :F_NAME,
           :F_DESCR
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_DOC_OUT_TYPES_GET (
    F_ID BIGINT)
RETURNS (
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  FOR SELECT
             F_NAME,
             F_DESCR
      FROM T_NSI_DOC_out_TYPES
      where
        f_id=:F_ID
      INTO
           :F_NAME,
           :F_DESCR
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_ED_IZM_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_NSI_ED_IZM
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_ED_IZM_GET (
    F_ED_IZM BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_SHORT_NAME VARCHAR(20))
AS
BEGIN
  FOR SELECT F_ID,
             F_NAME,
             F_SHORT_NAME
      FROM T_NSI_ED_IZM
      where
        f_id=:f_ed_izm
      INTO :F_ID,
           :F_NAME,
           :F_SHORT_NAME
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_ED_IZM_I (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_SHORT_NAME VARCHAR(20))
AS
BEGIN
  INSERT INTO T_NSI_ED_IZM (
    F_ID,
    F_NAME,
    F_SHORT_NAME)
  VALUES (
    :F_ID,
    :F_NAME,
    :F_SHORT_NAME);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_ED_IZM_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_SHORT_NAME VARCHAR(20))
AS
BEGIN
  FOR SELECT F_ID,
             F_NAME,
             F_SHORT_NAME
      FROM T_NSI_ED_IZM
      INTO :F_ID,
           :F_NAME,
           :F_SHORT_NAME
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_ED_IZM_U (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_SHORT_NAME VARCHAR(20))
AS
BEGIN
  UPDATE T_NSI_ED_IZM
  SET F_NAME = :F_NAME,
      F_SHORT_NAME = :F_SHORT_NAME
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOOD_IMPORT_PHOTO (
    F_ARTICLE VARCHAR(60),
    F_MMEDIA BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
declare variable V_GOOD_ID bigint;
begin
  if (exists(select f_id from t_nsi_goods where f_article=:f_article)) then
  begin
    if (not exists (select 1 from t_nsi_goods_mmedia where f_good in (select f_id from t_nsi_goods where f_article=:f_article))) then
    insert into t_nsi_goods_mmedia(f_good,f_memo)
      select f_id,:f_mmedia from t_nsi_goods where f_article=:f_article;
  end
end^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_NSI_GOODS
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_GET (
    NSI_ID BIGINT,
    F_GRP BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(255),
    F_GOODS_GRP BIGINT,
    F_GOODS_GRP_NAME VARCHAR(60),
    F_ED_IZM BIGINT,
    F_ARTICLE VARCHAR(20),
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_SCANCODE VARCHAR(60),
    F_DOP_INFO VARCHAR(255),
    F_PARTNER BIGINT,
    F_XML VARCHAR(10000))
AS
DECLARE VARIABLE V_PARTNER_INFO VARCHAR(10000) CHARACTER SET WIN1251;
DECLARE VARIABLE V_SCANCODES VARCHAR(10000) CHARACTER SET WIN1251;
begin
  /* Procedure Text */
  if (f_grp < 1) then
  begin
    f_grp=null;
  end
  if (nsi_id is null) then
  begin
    f_goods_grp=f_grp;
    f_name='Новый товар';
    select f_id from sp_t_nsi_goods_i(:f_name,:f_goods_grp,null,null) into :f_id;
  end
  else
  begin
    SELECT F_ID,
           F_NAME,
           f_goods_grp,
           f_article, 
           f_ed_izm,
           f_dop_info,
           f_partner
    FROM T_NSI_goods
    where
        f_id=:nsi_id
    INTO :F_ID,
         :F_NAME,
         :f_goods_grp,
         :f_article,
         :f_ed_izm,
         :f_dop_info,
         :f_partner;
  end
  if (f_goods_grp is not null) then
  begin
    select f_name from sp_t_nsi_goods_grp_get(:f_goods_grp,null) into :f_goods_grp_name;
  end
  select first 1 f_name, f_short_name from sp_t_nsi_ed_izm_get(:f_ed_izm)
    into :f_ed_izm_name,:f_ed_izm_short_name;
  select first 1 f_value from SP_T_NSI_SCANCODE_GET(:f_id) into :f_scancode;
/*  v_scancodes='<T_NSI_SCANCODE>';
  for select f_value from SP_T_NSI_SCANCODE_GET(:f_id) into :f_scancode do
  begin
     v_scancodes=v_scancodes||'<scancode>'||f_scancode||'</scancode>';
  end
  v_scancodes=v_scancodes||'</T_NSI_SCANCODE>';
  if (f_partner is not null) then
  begin
    select f_xml from sp_t_nsi_partner_get(:f_partner) into :v_partner_info;
  end
  else
  begin
    v_partner_info='';
  end
  f_xml='<T_NSI_GOOD>'||
    '<f_id>'||f_id||'</f_id>'||
    '<f_name><![CDATA['||coalesce(f_name,'')||']]></f_name>'||
    '<f_article><![CDATA['||coalesce(f_article,'')||']]></f_article>'||
    v_scancodes||
    v_partner_info||
    '</T_NSI_GOOD>'; */
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_GET_BY_SCANCODE (
    SCAN VARCHAR(20))
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(255),
    F_GOODS_GRP BIGINT,
    F_ED_IZM BIGINT,
    F_ARTICLE VARCHAR(20),
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_SCANCODE VARCHAR(60))
AS
begin
  /* Procedure Text */
    for SELECT F_good
    FROM
      t_nsi_scancode
    where
        f_value=:scan
    INTO :F_ID do
  begin
  if (f_id is not null) then
  begin
    select
      f_name,
      f_goods_grp,
      f_ed_izm,
      f_article,
      F_ED_IZM_NAME,
      F_ED_IZM_SHORT_NAME,
      F_SCANCODE
    from
      sp_t_nsi_goods_get(:f_id, null)
    into
      :F_NAME,
      :F_GOODS_GRP,
      :F_ED_IZM,
      :F_ARTICLE,
      :F_ED_IZM_NAME,
      :F_ED_IZM_SHORT_NAME,
      :F_SCANCODE;
  end
  else
  begin
    F_NAME=null;
    F_GOODS_GRP=null;
    F_ED_IZM=null;
    F_ARTICLE=null;
    F_ED_IZM_NAME=null;
    F_ED_IZM_SHORT_NAME=null;
    F_SCANCODE=null;
  end
  suspend;
  end
end^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_GRP_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_NSI_GOODS_GRP
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_GRP_GET (
    F_GRP BIGINT,
    F_PARENT_GRP BIGINT)
RETURNS (
    GRP_ID BIGINT,
    F_PARENT BIGINT,
    F_NAME VARCHAR(60))
AS
BEGIN
  if (coalesce(f_grp,-1)<1) then
  begin
    GRP_ID=GEN_ID(GEN_t_nsi_goods_grp_ID,1);
    F_PARENT=f_parent_grp;
    F_NAME='Новая группа';
    execute procedure sp_t_nsi_goods_grp_i(:grp_ID,:F_PARENT,:f_name);
  end
  else
  begin
    SELECT F_ID,
      coalesce(F_PARENT,-1),
      F_NAME
    FROM T_NSI_GOODS_GRP
    where
      f_id=:f_grp
    INTO
      :grp_ID,
      :F_PARENT,
      :F_NAME;
  end
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_GRP_I (
    F_ID BIGINT,
    F_PARENT BIGINT,
    F_NAME VARCHAR(60))
AS
BEGIN
  INSERT INTO T_NSI_GOODS_GRP (
    F_ID,
    F_PARENT,
    F_NAME)
  VALUES (
    :F_ID,
    :F_PARENT,
    :F_NAME);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_GRP_S
RETURNS (
    GRP_ID BIGINT,
    F_PARENT BIGINT,
    F_NAME VARCHAR(60))
AS
BEGIN
  FOR
    select -1,
        null, 
        'Все группы'
    from
        rdb$database
    union
    SELECT F_ID,
        coalesce(F_PARENT,-1),
        F_NAME
      FROM T_NSI_GOODS_GRP
      INTO :grp_ID,
           :F_PARENT,
           :F_NAME
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_GRP_U (
    F_ID BIGINT,
    F_PARENT BIGINT,
    F_NAME VARCHAR(60))
AS
BEGIN
  UPDATE T_NSI_GOODS_GRP
  SET F_PARENT = :F_PARENT,
      F_NAME = :F_NAME
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_I (
    F_NAME VARCHAR(255),
    F_GOODS_GRP BIGINT,
    F_ARTICLE VARCHAR(20),
    F_ED_IZM BIGINT)
RETURNS (
    F_ID BIGINT)
AS
BEGIN
  if (f_article is null) then
    select f_id from t_nsi_goods where upper(f_name)=upper(:f_name) into :f_id;
  else
    select f_id from t_nsi_goods where upper(f_article)=upper(:f_article) into :f_id;
  if (f_id is null) then
  begin
    f_id=GEN_ID(GEN_t_nsi_goods_ID,1);
    INSERT INTO T_NSI_GOODS (
      f_id,
      F_NAME,
      F_GOODS_GRP,
      F_ARTICLE,
      F_ED_IZM)
    VALUES (
      :F_ID,
      :F_NAME,
      :F_GOODS_GRP,
      :F_ARTICLE,
      :F_ED_IZM);
  end
  suspend;
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_MMEDIA_D (
    F_ID BIGINT)
AS
begin
  delete from t_nsi_goods_mmedia
  where (f_id = :f_id);
end^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_MMEDIA_I (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_NAME VARCHAR(60),
    F_MEMO BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
begin
  insert into t_nsi_goods_mmedia (
    f_id,
    f_good,
    f_name,
    f_memo)
  values (
    :f_id,
    :f_good,
    :f_name,
    :f_memo);
end^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_MMEDIA_S (
    F_GOOD_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_NAME VARCHAR(60),
    F_MEMO BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
begin
  for select f_id,
             f_good,
             f_name,
             f_memo
      from t_nsi_goods_mmedia
      where
        f_good=:f_good_id
      into :f_id,
           :f_good,
           :f_name,
           :f_memo
  do
  begin
    suspend;
  end
end^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_MMEDIA_U (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_NAME VARCHAR(60),
    F_MEMO BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
begin
  update t_nsi_goods_mmedia
  set f_good = :f_good,
      f_name = :f_name,
      f_memo = :f_memo
  where (f_id = :f_id);
end^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_S (
    GRP_ID INTEGER)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(255),
    F_GOODS_GRP BIGINT,
    F_ARTICLE VARCHAR(20),
    F_ED_IZM BIGINT,
    F_ED_IZM_NAME VARCHAR(60),
    F_ED_IZM_SHORT_NAME VARCHAR(20),
    F_DOP_INFO VARCHAR(255))
AS
BEGIN
  if (coalesce(grp_id,-1)<1) then
  begin
    FOR SELECT F_ID,
             F_NAME,
             F_GOODS_GRP,
             f_article,
             f_ed_izm,
             f_dop_info
    FROM T_NSI_GOODS
    INTO :F_ID,
         :F_NAME,
         :F_GOODS_GRP,
         :f_article,
         :f_ed_izm,
         :f_dop_info
    DO
    BEGIN
        f_ed_izm_name=null;
        f_ed_izm_short_name=null;
        select f_name, f_short_name from sp_t_nsi_ed_izm_get(:f_ed_izm) into :f_ed_izm_name,:f_ed_izm_short_name;
        SUSPEND;
    END
  end
  else
  begin
    FOR SELECT F_ID,
             F_NAME,
             F_GOODS_GRP,
             f_article,
             f_ed_izm,
             f_dop_info
    FROM T_NSI_GOODS
    where
        f_goods_grp=:grp_id
    INTO :F_ID,
         :F_NAME,
         :F_GOODS_GRP,
         :f_article,
         :f_ed_izm,
         :f_dop_info
    DO
    BEGIN
        f_ed_izm_name=null;
        f_ed_izm_short_name=null;
        select f_name, f_short_name from sp_t_nsi_ed_izm_get(:f_ed_izm) into :f_ed_izm_name,:f_ed_izm_short_name;
        SUSPEND;
    END
  end
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_U (
    F_ID BIGINT,
    F_NAME VARCHAR(255),
    F_GOODS_GRP BIGINT,
    F_ARTICLE VARCHAR(20),
    F_ED_IZM BIGINT,
    F_DOP_INFO VARCHAR(255))
AS
BEGIN
  UPDATE T_NSI_GOODS
  SET F_NAME = :F_NAME,
      F_GOODS_GRP = :F_GOODS_GRP,
      f_article = :f_article,
      f_ed_izm = :f_ed_izm,
      f_dop_info = :f_dop_info
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_GOODS_XML (
    F_GOOD BIGINT)
RETURNS (
    F_VALUE VARCHAR(10000))
AS
begin
  f_value='<T_NSI_GOOD>';
  suspend;
  select
    '<f_id>'||f_id||'</f_id>'||
    '<f_name><![CDATA['||coalesce(f_name,'')||']]></f_name>'||
    '<f_article><![CDATA['||coalesce(f_article,'')||']]></f_article>'||
    case
      when coalesce(f_partner,0)>0 then (select f_xml from sp_t_nsi_partner_get(f_partner))
      else ''
    end
  from sp_t_nsi_goods_get(:f_good,null)
  into :f_value;
  suspend;
  f_value='<T_NSI_SCANCODE>';
  suspend;
  for select '<scancode>'||f_value||'</scancode>' from SP_T_NSI_SCANCODE_GET(:f_good) into :f_value do
  begin
     suspend;
  end
  f_value='</T_NSI_SCANCODE>';
  suspend;
  f_value='</T_NSI_GOOD>';
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_T_NSI_MONEY_IN_TYPES_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_NSI_MONEY_IN_TYPES
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_MONEY_IN_TYPES_GET (
    F_MONEY_TYPE BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN

  FOR SELECT F_ID,
             F_NAME,
             F_DESCR
      FROM T_NSI_MONEY_IN_TYPES
      where
        f_id=:f_money_type
      INTO :F_ID,
           :F_NAME,
           :F_DESCR
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_MONEY_IN_TYPES_I (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  INSERT INTO T_NSI_MONEY_IN_TYPES (
    F_ID,
    F_NAME,
    F_DESCR)
  VALUES (
    :F_ID,
    :F_NAME,
    :F_DESCR);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_MONEY_IN_TYPES_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  FOR SELECT F_ID,
             F_NAME,
             F_DESCR
      FROM T_NSI_MONEY_IN_TYPES
      INTO :F_ID,
           :F_NAME,
           :F_DESCR
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_MONEY_IN_TYPES_U (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_DESCR VARCHAR(10000))
AS
BEGIN
  UPDATE T_NSI_MONEY_IN_TYPES
  SET F_NAME = :F_NAME,
      F_DESCR = :F_DESCR
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_NSI_PARTNER
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_GET (
    NSI_ID INTEGER)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20),
    F_BANK VARCHAR(255),
    F_BANK_RSCH VARCHAR(20),
    F_BANK_BIK VARCHAR(20),
    F_BANK_KSCH VARCHAR(20),
    F_BANK_ADRES VARCHAR(255),
    F_XML VARCHAR(10000))
AS
DECLARE VARIABLE F_BANK_XML VARCHAR(10000) CHARACTER SET WIN1251;
begin
  /* Procedure Text */
  if (coalesce(nsi_id,0)<1) then
  begin
    f_id=GEN_ID(GEN_t_nsi_partner_ID,1);
    execute procedure sp_t_nsi_partner_i(:f_id,null,null,null,null,null);
  end
  else
  begin
    SELECT F_ID,
           F_NAME,
           F_U_NAME,
           F_U_ADDRES,
           F_INN,
           F_KPP
    FROM T_NSI_PARTNER
    where
        f_id=:nsi_id
    INTO :F_ID,
         :F_NAME,
         :F_U_NAME,
         :F_U_ADDRES,
         :F_INN,
         :F_KPP;
    select first 1

      F_R_SCH,
      f_bank_name,
      F_BANK_ADRES,
      F_BANK_K_SCH,
      f_bank_bik,
      f_xml
      from sp_t_partner_bank_s(:f_id)
    into
      :f_bank_rsch,
      :f_bank,
      :f_bank_adres,
      :f_bank_ksch,
      :f_bank_bik,
      :f_bank_xml;
  end
  f_xml='<T_NSI_PARTNER><f_id>'||f_id||'</f_id>'||
    '<f_name><![CDATA['||coalesce(f_name,'')||']]></f_name>'||
    '<f_u_name><![CDATA['||coalesce(f_u_name,'')||']]></f_u_name>'||
    '<f_inn>'||coalesce(f_inn,'')||'</f_inn>'||
    '<f_kpp>'||coalesce(f_kpp,'')||'</f_kpp>'||
    coalesce(f_bank_xml,'')||
    '</T_NSI_PARTNER>';
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_I (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20))
AS
BEGIN
  INSERT INTO T_NSI_PARTNER (
    F_ID,
    F_NAME,
    F_U_NAME,
    F_U_ADDRES,
    F_INN,
    F_KPP)
  VALUES (
    :F_ID,
    :F_NAME,
    :F_U_NAME,
    :F_U_ADDRES,
    :F_INN,
    :F_KPP);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_INFO_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_NSI_PARTNER_INFO
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_INFO_GET (
    F_PARTNER BIGINT,
    F_INFO_NAME BIGINT)
RETURNS (
    F_RESULT VARCHAR(255))
AS
DECLARE VARIABLE V_RESULT VARCHAR(60) CHARACTER SET WIN1251;
begin
  /* Procedure Text */
    FOR SELECT

             F_VALUE||';'
      FROM T_NSI_PARTNER_iNFO
      where
           f_partner=:f_partner
           and f_info_name=:f_info_name
      INTO :v_result
  DO
  BEGIN
    f_result=coalesce(f_result, '')||coalesce(v_result,'');
  END
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_INFO_I (
    F_ID BIGINT,
    F_PARTNER BIGINT,
    F_INFO_NAME BIGINT,
    F_VALUE VARCHAR(100))
AS
BEGIN
  INSERT INTO T_NSI_PARTNER_INFO (
    F_ID,
    F_PARTNER,
    F_INFO_NAME,
    F_VALUE)
  VALUES (
    :F_ID,
    :F_PARTNER,
    :F_INFO_NAME,
    :F_VALUE);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_INFO_S (
    PARTNER_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_PARTNER BIGINT,
    F_INFO VARCHAR(60),
    F_INFO_NAME BIGINT,
    F_VALUE VARCHAR(100))
AS
BEGIN
  FOR SELECT F_ID,
             F_PARTNER,
             F_INFO_NAME,
             F_VALUE
      FROM T_NSI_PARTNER_iNFO
      where
           f_partner=:partner_id
      INTO :F_ID,
           :F_PARTNER,
           :F_INFO_NAME,
           :F_VALUE
  DO
  BEGIN
    select f_name from t_nsi_info_name where f_id=:f_info_name into :f_info;
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_INFO_U (
    F_ID BIGINT,
    F_PARTNER BIGINT,
    F_INFO_NAME BIGINT,
    F_VALUE VARCHAR(100))
AS
BEGIN
  UPDATE T_NSI_PARTNER_INFO
  SET F_PARTNER = :F_PARTNER,
      F_INFO_NAME = :F_INFO_NAME,
      F_VALUE = :F_VALUE
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20))
AS
BEGIN
  FOR SELECT F_ID,
             F_NAME,
             F_U_NAME,
             F_U_ADDRES,
             F_INN,
             F_KPP
      FROM T_NSI_PARTNER
      INTO :F_ID,
           :F_NAME,
           :F_U_NAME,
           :F_U_ADDRES,
           :F_INN,
           :F_KPP
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_PARTNER_U (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_U_NAME VARCHAR(255),
    F_U_ADDRES VARCHAR(255),
    F_INN VARCHAR(20),
    F_KPP VARCHAR(20))
AS
BEGIN
  UPDATE T_NSI_PARTNER
  SET F_NAME = :F_NAME,
      F_U_NAME = :F_U_NAME,
      F_U_ADDRES = :F_U_ADDRES,
      F_INN = :F_INN,
      F_KPP = :F_KPP
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_PRICE_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_NSI_PRICE
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_PRICE_GET (
    PRICE_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_FORMULA VARCHAR(255),
    F_ROUND NUMERIC(15,3),
    F_PARENT_OBJECT BIGINT,
    F_SAVE_RESULT SMALLINT)
AS
BEGIN
  if (price_id is null) then
  begin
    price_id=GEN_ID(GEN_t_nsi_price_ID,1);
    EXECUTE PROCEDURE SP_T_NSI_PRICE_I(price_id, 'Новый прайс', 4, '0', 0.01);
  end
  FOR SELECT F_ID,
             F_NAME,
             f_formula,
             f_round,
             f_parent_object,
             f_save_result
      FROM T_NSI_PRICE
      where
        f_id=:price_id
      INTO :F_ID,
           :F_NAME,
           :f_formula,
           :f_round,
           :f_parent_object,
           :f_save_result
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_PRICE_I (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_PARENT_OBJECT BIGINT,
    F_FORMULA VARCHAR(255),
    F_ROUND NUMERIC(15,3))
AS
BEGIN
  INSERT INTO T_NSI_PRICE (
    F_ID,
    F_NAME,
    F_PARENT_OBJECT,
    F_FORMULA,
    f_round)
  VALUES (
    :F_ID,
    :F_NAME,
    :F_PARENT_OBJECT,
    :F_FORMULA,
    :f_round);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_PRICE_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_PARENT_OBJECT BIGINT,
    F_FORMULA VARCHAR(255),
    F_ROUND NUMERIC(15,3),
    F_SAVE_RESULT SMALLINT)
AS
BEGIN
  FOR SELECT F_ID,
             F_NAME,
             F_PARENT_OBJECT,
             F_FORMULA,
             F_ROUND,
             f_save_result
      FROM T_NSI_PRICE
      INTO :F_ID,
           :F_NAME,
           :F_PARENT_OBJECT,
           :F_FORMULA,
           :F_ROUND,
           :f_save_result
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_PRICE_U (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_PARENT_OBJECT BIGINT,
    F_FORMULA VARCHAR(255),
    F_ROUND NUMERIC(15,3),
    F_SAVE_RESULT SMALLINT)
AS
BEGIN
  UPDATE T_NSI_PRICE
  SET F_NAME = :F_NAME,
      F_PARENT_OBJECT = :F_PARENT_OBJECT,
      F_FORMULA = :F_FORMULA,
      f_round = :f_round,
      f_save_result=:f_save_result
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_SCANCODE_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_NSI_SCANCODE
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_SCANCODE_GET (
    F_GOOD_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_VALUE VARCHAR(60),
    F_GOOD BIGINT,
    F_COUNT FLOAT)
AS
BEGIN
  FOR SELECT F_ID,
             F_VALUE,
             F_GOOD,
             F_COUNT
      FROM T_NSI_SCANCODE
      where
        f_good=:f_good_id
      INTO :F_ID,
           :F_VALUE,
           :F_GOOD,
           :F_COUNT
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_SCANCODE_I (
    F_ID BIGINT,
    F_VALUE VARCHAR(60),
    F_GOOD BIGINT,
    F_COUNT FLOAT)
AS
BEGIN
  INSERT INTO T_NSI_SCANCODE (
    F_ID,
    F_VALUE,
    F_GOOD,
    F_COUNT)
  VALUES (
    :F_ID,
    :F_VALUE,
    :F_GOOD,
    :F_COUNT);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_SCANCODE_S (
    F_SCANCODE VARCHAR(60))
RETURNS (
    F_ID BIGINT,
    F_VALUE VARCHAR(60),
    F_GOOD BIGINT,
    F_COUNT FLOAT)
AS
BEGIN
  FOR SELECT F_ID,
             F_VALUE,
             F_GOOD,
             F_COUNT
      FROM T_NSI_SCANCODE
      where
        f_value=:f_scancode
      INTO :F_ID,
           :F_VALUE,
           :F_GOOD,
           :F_COUNT
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_SCANCODE_S_BY_GOOD (
    F_IN_GOOD VARCHAR(60))
RETURNS (
    F_ID BIGINT,
    F_VALUE VARCHAR(60),
    F_GOOD BIGINT,
    F_COUNT FLOAT)
AS
BEGIN
  FOR SELECT F_ID,
             F_VALUE,
             F_GOOD,
             F_COUNT
      FROM T_NSI_SCANCODE
      where
        f_good=:F_in_good
      INTO :F_ID,
           :F_VALUE,
           :F_GOOD,
           :F_COUNT
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_SCANCODE_U (
    F_ID BIGINT,
    F_VALUE VARCHAR(60),
    F_GOOD BIGINT,
    F_COUNT FLOAT)
AS
BEGIN
  UPDATE T_NSI_SCANCODE
  SET F_VALUE = :F_VALUE,
      F_GOOD = :F_GOOD,
      F_COUNT = :F_COUNT
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_SKLAD_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_NSI_SKLAD
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_SKLAD_GET (
    SKLAD_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_ADDRES VARCHAR(255),
    F_PARTNER BIGINT,
    F_PARTNER_NAME VARCHAR(60),
    F_PARTNER_INN VARCHAR(20),
    F_PARTNER_KPP VARCHAR(20),
    F_PARTNER_ADRES VARCHAR(255),
    F_PARTNER_BANK VARCHAR(255),
    F_PARTNER_BANK_ADRES VARCHAR(255),
    F_PARTNER_BANK_RSCH VARCHAR(20),
    F_PARTNER_BANK_KSCH VARCHAR(20),
    F_PARTNER_BANK_BIK VARCHAR(20),
    F_XML VARCHAR(10000),
    F_PRICE_IN BIGINT,
    F_PRICE_OUT BIGINT,
    F_PRICE_IN_NAME VARCHAR(60),
    F_PRICE_OUT_NAME VARCHAR(60),
    F_PARTNER_ROZN BIGINT,
    F_PARTNER_ROZN_NAME VARCHAR(255))
AS
declare variable F_PARTNER_XML varchar(10000);
BEGIN
  if (sklad_id>0) then
  begin
    FOR SELECT F_ID,
             F_NAME,
             F_ADDRES,
             f_price_in,
             f_price_out,
             (select f_name from t_nsi_price where f_id=f_price_in),
             (select f_name from t_nsi_price where f_id=f_price_out),
             f_partner,
             f_partner_rozn,
             (select f_name from t_nsi_partner where f_id=f_partner_rozn)
      FROM T_NSI_SKLAD
      where
        f_id=:sklad_id
      INTO :F_ID,
           :F_NAME,
           :F_ADDRES,
           :f_price_in,
           :f_price_out,
           :f_price_in_name,
           :f_price_out_name,
           :f_partner, 
           :f_partner_rozn,
           :f_partner_rozn_name
    DO
    BEGIN
      if (not f_partner is null) then
        select
          f_xml,f_name,f_inn,
          f_kpp,f_bank,f_bank_rsch,
          f_bank_bik,f_bank_ksch

        from
          sp_t_nsi_partner_get(:f_partner) p
        into
          :f_partner_xml,:f_partner_name,
          :f_partner_inn,:f_partner_kpp,
          :f_partner_bank,:f_partner_bank_rsch,
          :f_partner_bank_bik, :f_partner_bank_ksch;
      else
        f_partner_xml='';
      f_xml='<T_NSI_SKLAD>'||
        '<f_id>'||f_id||'</f_id>'||
        '<f_name><![CDATA['||coalesce(f_name,'')||']]></f_name>'||
        '<f_addres><![CDATA['||coalesce(f_addres,'')||']]></f_addres>'||
        f_partner_xml||
        '</T_NSI_SKLAD>';
      SUSPEND;
    END
  end
  else
  begin
    f_id=GEN_ID(GEN_t_nsi_sklad_ID,1);
    execute procedure sp_t_nsi_sklad_i(:f_id, :f_name, :f_addres, :f_partner);
    if (not f_partner is null) then
        select
          f_xml
          from sp_t_nsi_partner_get(:f_partner) p
        into
          :f_partner_xml;
    else
      f_partner_xml='';
    f_xml='<T_NSI_SKLAD>'||
      '<f_id>'||f_id||'</f_id>'||
      '<f_name><![CDATA['||coalesce(f_name,'')||']]></f_name>'||
      '<f_addres><![CDATA['||coalesce(f_addres,'')||']]></f_addres>'||
      f_partner_xml||
      '</T_NSI_SKLAD>';
    SUSPEND;
  end
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_SKLAD_I (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_ADDRES VARCHAR(255),
    F_PARTNER BIGINT)
AS
BEGIN
  INSERT INTO T_NSI_SKLAD (
    F_ID,
    F_NAME,
    F_ADDRES,
    F_Partner)
  VALUES (
    :F_ID,
    :F_NAME,
    :F_ADDRES,
    :f_partner);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_SKLAD_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_ADDRES VARCHAR(255))
AS
BEGIN
  FOR SELECT F_ID,
             F_NAME,
             F_ADDRES
      FROM T_NSI_SKLAD
      INTO :F_ID,
           :F_NAME,
           :F_ADDRES
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_SKLAD_U (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_ADDRES VARCHAR(255),
    F_PARTNER BIGINT,
    F_PRICE_IN BIGINT,
    F_PRICE_OUT BIGINT,
    F_PARTNER_ROZN BIGINT)
AS
BEGIN
  UPDATE T_NSI_SKLAD
  SET F_NAME = coalesce(:F_NAME,f_name),
      F_ADDRES = coalesce(:F_ADDRES,f_addres),
      F_PARTNER = coalesce(:f_partner,f_partner),
      f_price_in = coalesce(:f_price_in,f_price_in),
      f_price_out = coalesce(:f_price_out,f_price_out),
      f_partner_rozn = coalesce(:f_partner_rozn,f_partner_rozn)
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_STATE_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_NSI_STATE
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_STATE_GET (
    STATE_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_PARENT BIGINT)
AS
BEGIN
  FOR SELECT F_ID,
             F_NAME,
             F_PARENT
      FROM T_NSI_STATE
      where
        f_id=:state_id
      INTO :F_ID,
           :F_NAME,
           :F_PARENT
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_STATE_I (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_PARENT BIGINT)
AS
BEGIN
  INSERT INTO T_NSI_STATE (
    F_ID,
    F_NAME,
    F_PARENT)
  VALUES (
    :F_ID,
    :F_NAME,
    :F_PARENT);
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_STATE_S
RETURNS (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_PARENT BIGINT)
AS
BEGIN
  FOR SELECT F_ID,
             F_NAME,
             F_PARENT
      FROM T_NSI_STATE
      INTO :F_ID,
           :F_NAME,
           :F_PARENT
  DO
  BEGIN
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_NSI_STATE_U (
    F_ID BIGINT,
    F_NAME VARCHAR(60),
    F_PARENT BIGINT)
AS
BEGIN
  UPDATE T_NSI_STATE
  SET F_NAME = :F_NAME,
      F_PARENT = :F_PARENT
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_PARTNER_BANK_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_PARTNER_BANK
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_PARTNER_BANK_I (
    F_ID BIGINT,
    F_PARTNER BIGINT,
    F_BANK BIGINT,
    F_R_SCH VARCHAR(60))
AS
BEGIN
  INSERT INTO T_PARTNER_BANK (
    F_ID,
    F_PARTNER,
    F_BANK,
    F_R_SCH)
  VALUES (
    :F_ID,
    :F_PARTNER,
    :F_BANK,
    :F_R_SCH);
END^


CREATE OR ALTER PROCEDURE SP_T_PARTNER_BANK_S (
    F_PARTNER_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_PARTNER BIGINT,
    F_BANK BIGINT,
    F_BANK_NAME VARCHAR(60),
    F_BANK_KPP VARCHAR(20),
    F_BANK_INN VARCHAR(20),
    F_BANK_ADRES VARCHAR(255),
    F_BANK_K_SCH VARCHAR(60),
    F_R_SCH VARCHAR(60),
    F_BANK_BIK VARCHAR(20),
    F_XML VARCHAR(10000))
AS
DECLARE VARIABLE F_BANK_XML VARCHAR(10000) CHARACTER SET WIN1251;
BEGIN
    FOR
      select
        b.f_id,
        b.f_bank,
        b.f_r_sch
      from
        t_partner_bank b
      where
        b.f_partner=:f_partner_id
      into
        :f_id,
        :f_bank,
        :f_r_sch
    DO
    BEGIN
      if (f_id>0) then
      begin
        SELECT
          F_NAME,
          F_U_ADDRES,
          F_INN,
          F_KPP,
          F_K_SCH,
          f_bik,
          f_xml
        FROM sp_t_nsi_bank_get(:f_bank)
        INTO
          :F_BANK_NAME,
          :F_BANK_ADRES,
          :F_BANK_INN,
          :F_BANK_KPP,
          :F_BANK_K_SCH,
          :F_BANK_BIK,
          :f_bank_xml;
      end
      else
      begin
        F_BANK_NAME=null;
        F_BANK_ADRES=null;
        F_BANK_INN=null;
        F_BANK_KPP=null;
        F_BANK_K_SCH=null;
        f_bank_xml=null;
      end
      f_xml='<T_PARTNER_BANK>'||
        '<f_r_sch>'||coalesce(f_r_sch,'')||'</f_r_sch>'||
        coalesce(f_bank_xml,'')||
        '</T_PARTNER_BANK>';
      SUSPEND;
    END
END^


CREATE OR ALTER PROCEDURE SP_T_PARTNER_BANK_U (
    F_ID BIGINT,
    F_PARTNER BIGINT,
    F_BANK BIGINT,
    F_R_SCH VARCHAR(60))
AS
BEGIN
  UPDATE T_PARTNER_BANK
  SET F_PARTNER = :F_PARTNER,
      F_BANK = :F_BANK,
      F_R_SCH = :F_R_SCH
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_PRICE_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_PRICE
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_PRICE_GET (
    F_PRICE_ID BIGINT,
    F_GOOD_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_STR_DATE DATE,
    F_MAKE_DATE TIMESTAMP,
    F_VALUE FLOAT)
AS
DECLARE VARIABLE F_SAVE_RES SMALLINT;
DECLARE VARIABLE F_PARENT_PRICE BIGINT;
DECLARE VARIABLE F_ROUND NUMERIC(15,3);
DECLARE VARIABLE F_FORMULA NUMERIC(15,3);
begin
  /* Procedure Text */
  if (exists (select f_id from t_nsi_price where f_id=:f_price_id)) then
  begin
    select f_save_result,f_parent_object,f_round,f_formula
    from
      sp_t_nsi_price_get(:f_price_id)
    into
      :f_save_res,:f_parent_price,:f_round,:f_formula;
  end
  else
    exit;
  if (f_save_res=1) then
  begin
    select
      p.f_id,
      p.f_good,
      p.f_price,
      p.f_str_date,
      p.f_make_date,
      p.f_value
    from t_price p
    where
      p.f_good=:f_good_id
      and p.f_price=:f_price_id
      and p.f_str_date<='now'
      and p.f_active=1
    INTO :F_ID,
      :F_GOOD,
      :F_PRICE,
      :F_STR_DATE,
      :F_MAKE_DATE,
      :f_value;
  end
  else
  begin
    select
      p.f_good,
      (select f_result from sp_round((p.f_value+p.f_value*:f_formula/100),:f_round))
    from sp_t_price_get(:f_parent_price,:f_good_id) p
    INTO
      :F_GOOD,
      :f_value;
  end
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_T_PRICE_I (
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_STR_DATE DATE,
    F_VALUE FLOAT,
    F_SOURCE BIGINT = NULL,
    F_ACTIVE SMALLINT = 1)
AS
BEGIN
  INSERT INTO T_PRICE (
    F_GOOD,
    F_PRICE,
    F_STR_DATE,
    F_VALUE,
    f_source,
    f_active)
  VALUES (
    :F_GOOD,
    :F_PRICE,
    :F_STR_DATE,
    :f_value,
    :f_source,
    :f_active);
END^


CREATE OR ALTER PROCEDURE SP_T_PRICE_S (
    F_PRICE_ID BIGINT)
RETURNS (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_STR_DATE DATE,
    F_MAKE_DATE TIMESTAMP,
    F_GOOD_NAME VARCHAR(255),
    F_VALUE FLOAT,
    F_DEFAULT_SKLAD_OST NUMERIC(15,3),
    F_ARTICLE VARCHAR(20))
AS
DECLARE VARIABLE F_DEFAULT_SCLAD BIGINT;
DECLARE VARIABLE F_SAVE_RES SMALLINT;
DECLARE VARIABLE F_PARENT_PRICE BIGINT;
DECLARE VARIABLE F_ROUND NUMERIC(15,3);
DECLARE VARIABLE F_FORMULA NUMERIC(15,3);
BEGIN
  select param_value from SP_GET_SYS_PARAM('DEFAULT_SKLAD') into :f_default_sclad;
  select f_save_result,f_parent_object,f_round,f_formula
  from
    sp_t_nsi_price_get(:f_price_id)
  into
    :f_save_res,:f_parent_price,:f_round,:f_formula;
  if (f_save_res=1) then
  begin
    FOR SELECT p.F_ID,
               p.F_GOOD,
               p.F_PRICE,
               p.F_STR_DATE,
               p.F_MAKE_DATE,
               p.f_value
        FROM
          T_PRICE p
        where
          f_price=:f_price_id
          and f_active=1
        INTO :F_ID,
             :F_GOOD,
             :F_PRICE,
             :F_STR_DATE,
             :F_MAKE_DATE,
             :f_value
    DO
    BEGIN
      select f_name,f_article from sp_t_nsi_goods_get(coalesce(:f_good,0),null) into :f_good_name,:f_article;
--    select f_move_out from sp_t_reg_good_get(:f_good,'now',:f_default_sclad) into :f_default_sklad_ost;
      SUSPEND;
    END
  end
  else
  begin
    for select
        null,
        F_GOOD,
        F_PRICE,
        F_STR_DATE,
        F_MAKE_DATE,
        (select f_result from sp_round((p.f_value+p.f_value*:f_formula/100),:f_round)),
        f_good_name,
        f_article
      from
        sp_t_price_s(:f_parent_price) p
      into
        :F_ID,
        :F_GOOD,
        :F_PRICE,
        :F_STR_DATE,
        :F_MAKE_DATE,
        :f_value,
        :f_good_name,
        :f_article
    do
    begin
      suspend;
    end
  end
END^


CREATE OR ALTER PROCEDURE SP_T_PRICE_U (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_PRICE BIGINT,
    F_VALUE FLOAT,
    F_STR_DATE DATE = 'now')
AS
BEGIN
  UPDATE T_PRICE
  SET F_GOOD = :F_GOOD,
      F_PRICE = :F_PRICE,
      F_STR_DATE = :F_STR_DATE,
      f_value = :f_value
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_REG_GOOD_D (
    F_ID BIGINT)
AS
BEGIN
  DELETE FROM T_REG_GOOD
  WHERE (F_ID = :F_ID);
END^


CREATE OR ALTER PROCEDURE SP_T_REG_GOOD_GET (
    F_GOOD BIGINT,
    F_DATE DATE,
    F_SKLAD BIGINT)
RETURNS (
    F_START_OST FLOAT,
    F_MOVE_IN FLOAT,
    F_MOVE_OUT FLOAT,
    F_END_OST FLOAT)
AS
DECLARE VARIABLE F_REG_DATE DATE;
begin
  select
    max(r.f_date)
  from
    t_reg_good r
  where
    r.f_good=:f_good
    and r.f_date<:f_date
    and r.f_sklad=:f_sklad
  into
    :f_reg_date;
  select
    r.f_end_ost
  from
    t_reg_good r
  where
    r.f_date=:f_reg_date
    and r.f_good=:f_good
    and r.f_sklad=:f_sklad
  into :f_start_ost;
  f_reg_date=coalesce(f_reg_date,f_date-1);
--==========================================================
  select
    sum(s.f_cnt)
  from
    t_doc_in d
    inner join t_doc_in_str s on d.f_id=s.f_doc_in and d.f_sklad=:f_sklad
      and s.f_good=:f_good and d.f_state>=(select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE'))
  where
    d.f_date>:f_reg_date
    and d.f_date<=:f_date
  into
    :f_move_in;
  select
    sum(s.f_cnt)
  from
    t_doc_out d
    inner join t_doc_out_str s on d.f_id=s.f_doc_out and d.f_sklad=:f_sklad
      and s.f_good=:f_good and d.f_state>=(select param_value from sp_get_sys_param('CHANGE_SKLAD_OST_STATE'))
  where
    d.f_date>:f_reg_date
    and d.f_date<=:f_date
  into
    :f_move_out;
--========================================================
/*
  select
    sum(coalesce(r.f_move_in,0)),
    sum(coalesce(r.f_move_out,0))
  from
    t_reg_good r
  where
    r.f_date > coalesce(:f_reg_date,cast('01.01.1900' as date)) and r.f_date < :f_date
    and r.f_good=:f_good
    and r.f_sklad=:f_sklad
  into
    :f_move_in,
    :f_move_out;
  f_start_ost=coalesce(f_start_ost,0)+coalesce(f_move_in,0)-coalesce(f_move_out,0);
  select
    sum(coalesce(r.f_move_in,0)),
    sum(coalesce(r.f_move_out,0))
  from
    t_reg_good r
  where
    r.f_date=:f_date
    and r.f_good=:f_good
    and r.f_sklad=:f_sklad
  into
    :f_move_in,
    :f_move_out;
*/
  f_end_ost=coalesce(f_start_ost,0)+coalesce(f_move_in,0)-coalesce(f_move_out,0);
  f_move_in=coalesce(f_move_in, 0);
  f_move_out=coalesce(f_move_out,0);
  suspend;
end^


CREATE OR ALTER PROCEDURE SP_T_REG_GOOD_I (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_SKLAD BIGINT,
    F_DATE DATE,
    F_STR_OST FLOAT,
    F_MOVE_IN FLOAT,
    F_MOVE_OUT FLOAT)
AS
BEGIN
  INSERT INTO T_REG_GOOD (
    F_ID,
    F_GOOD,
    F_SKLAD,
    F_DATE,
    F_STR_OST,
    F_MOVE_IN,
    F_MOVE_OUT)
  VALUES (
    :F_ID,
    :F_GOOD,
    :F_SKLAD,
    :F_DATE,
    :F_STR_OST,
    :F_MOVE_IN,
    :F_MOVE_OUT);
END^


CREATE OR ALTER PROCEDURE SP_T_REG_GOOD_S (
    F_SKLAD_IN BIGINT,
    F_DATE_IN DATE,
    F_PRICE BIGINT)
RETURNS (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_SKLAD BIGINT,
    F_DATE DATE,
    F_STR_OST FLOAT,
    F_MOVE_IN FLOAT,
    F_MOVE_OUT FLOAT,
    F_END_OST FLOAT,
    F_GOOD_NAME VARCHAR(255),
    F_GOOD_ARTICLE VARCHAR(20),
    F_GOOD_GRP_NAME VARCHAR(60),
    F_PRICE_VAL NUMERIC(15,3))
AS
DECLARE VARIABLE V_PRICE BIGINT;
BEGIN
  if (exists (select f_id from t_nsi_price where f_id=:f_price)) then
    v_price=f_price;
  else
    v_price=0;
  FOR SELECT
             F_GOOD,
             F_SKLAD,
             max(F_DATE)
      FROM T_REG_GOOD
      where
        f_sklad=:f_sklad_in
        and f_date<=:f_date_in
      group by
        F_GOOD,
        F_SKLAD
      INTO
        :F_GOOD,
        :F_SKLAD,
        :F_DATE
  DO
  BEGIN
    select
      r.f_str_ost,
      r.f_move_in,
      r.f_move_out,
      r.f_end_ost
    from
      t_reg_good r
    where
      f_good=:f_good
      and f_sklad=:f_sklad_in
      and f_date=:f_date
    into
      :F_STR_OST,
      :F_MOVE_IN,
      :F_MOVE_OUT,
      :F_END_OST;
    select f_name,f_article,f_goods_grp_name from sp_t_nsi_goods_get(:f_good,null) into :f_good_name,:f_good_article,:f_good_grp_name;
    if (v_price>0) then
        select f_value from sp_t_price_get(:v_price,:f_good) into :f_price_val;
    else
        f_price_val=0;
    SUSPEND;
  END
END^


CREATE OR ALTER PROCEDURE SP_T_REG_GOOD_U (
    F_ID BIGINT,
    F_GOOD BIGINT,
    F_SKLAD BIGINT,
    F_DATE DATE,
    F_STR_OST FLOAT,
    F_MOVE_IN FLOAT,
    F_MOVE_OUT FLOAT)
AS
BEGIN
  UPDATE T_REG_GOOD
  SET F_GOOD = :F_GOOD,
      F_SKLAD = :F_SKLAD,
      F_DATE = :F_DATE,
      F_STR_OST = :F_STR_OST,
      F_MOVE_IN = :F_MOVE_IN,
      F_MOVE_OUT = :F_MOVE_OUT
  WHERE (F_ID = :F_ID);
END^



SET TERM ; ^

EXECUTE PROCEDURE SP_SET_SYS_PARAM('DEFAULT_SKLAD', '1');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('DEFAULT_IN_PRICE', '4');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('IN_DOC_STATE', '1');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('DEFAULT_OUT_PRICE', '1');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('OUT_DOC_STATE', '1');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('CHANGE_SKLAD_OST_STATE', '3');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('CHECK_ZAPAS', '1');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('IN_DOC_TYPE', '1');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('OUT_DOC_TYPE', '1');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('MOVE_DOC_STATE', '1');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('INVENTORY_DOC_STATE', '1');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('MOVE_DOC_TYPE', '1');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('OUT_DOC_SKIDKA', '1');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('IN_DOC_ARCH', '4');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('OUT_DOC_ARCH', '4');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('MOVE_DOC_ARCH', '4');
EXECUTE PROCEDURE SP_SET_SYS_PARAM('PROGRAM_VERSION', '1.0');

alter trigger T_DOC_OUT_BUD0 inactive;
update t_doc_out set f_type=1 where f_type is null;
alter trigger T_DOC_OUT_BUD0 active;

commit work;

INSERT INTO T_NSI_DOC_OUT_TYPES (F_ID, F_NAME, F_DESCR)
select 3, 'Возврат поставщику', NULL
from
T_NSI_DOC_OUT_TYPES
where
f_id=1 and not exists(select f_id from T_NSI_DOC_OUT_TYPES where f_id=3);

COMMIT WORK;

INSERT INTO T_NSI_MONEY_IN_TYPES (F_ID, F_NAME, F_DESCR)
select 3, 'Платежная карта', NULL
from
T_NSI_MONEY_IN_TYPES
where
f_id=1 and not exists(select f_id from T_NSI_MONEY_IN_TYPES where f_id=3);

COMMIT WORK;

